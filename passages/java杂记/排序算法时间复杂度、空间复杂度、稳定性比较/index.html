<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content>
    <meta name="renderer" content="webkit">
    <meta name="copyright" content>
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content>
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>排序算法时间复杂度、空间复杂度、稳定性比较 · fi3ework&#39;s Studio</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >yizhenxiao.github.io</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">排序算法时间复杂度、空间复杂度、稳定性比较</a>
            </div>
    </div>
    
    <a class="home-link" href=/>yizhenxiao.github.io</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            排序算法时间复杂度、空间复杂度、稳定性比较
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">4.8k</span>阅读时长: <span class="post-count reading-time">20 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/07/08</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <hr>
<p> 版权声明：本文为博主原创文章，未经博主允许不得转载。 <a href="https://blog.csdn.net/yushiyi6453/article/details/76407640" target="_blank" rel="noopener">https://blog.csdn.net/yushiyi6453/article/details/76407640</a><br>排序算法分类</p>
<p>排序算法比较表格填空<br>排序算法    平均时间复杂度    最坏时间复杂度    空间复杂度    是否稳定<br>冒泡排序    :————-:    :—–:    :—–:    :—–:<br>选择排序    :————-:    :—–:    :—–:    :—–:<br>直接插入排序    :————-:    :—–:    :—–:    :—–:<br>归并排序    :————-:    :—–:    :—–:    :—–:<br>快速排序    :————-:    :—–:    :—–:    :—–:<br>堆排序    :————-:    :—–:    :—–:    :—–:<br>希尔排序    :————-:    :—–:    :—–:    :—–:<br>计数排序    :————-:    :—–:    :—–:    :—–:<br>基数排序    :————-:    :—–:    :—–:    :—–:<br>排序算法比较表格<br>排序算法    平均时间复杂度    最坏时间复杂度    空间复杂度    是否稳定<br>冒泡排序    O（n2）O（n2）    O（n2）O（n2）    O（1）O（1）    是<br>选择排序    O（n2）O（n2）    O（n2）O（n2）    O（1）O（1）    不是<br>直接插入排序    O（n2）O（n2）    O（n2）O（n2）    O（1）O（1）    是<br>归并排序    O(nlogn)O(nlogn)    O(nlogn)O(nlogn)    O（n）O（n）    是<br>快速排序    O(nlogn)O(nlogn)    O（n2）O（n2）    O（logn）O（logn）    不是<br>堆排序    O(nlogn)O(nlogn)    O(nlogn)O(nlogn)    O（1）O（1）    不是<br>希尔排序    O(nlogn)O(nlogn)    O（ns）O（ns）    O（1）O（1）    不是<br>计数排序    O(n+k)O(n+k)    O(n+k)O(n+k)    O(n+k)O(n+k)    是<br>基数排序    O(N∗M)O(N∗M)    O(N∗M)O(N∗M)    O(M)O(M)    是<br>注：<br>1 归并排序可以通过手摇算法将空间复杂度降到O（1），但是时间复杂度会提高。<br>2 基数排序时间复杂度为O（N*M），其中N为数据个数，M为数据位数。<br>辅助记忆<br>时间复杂度记忆-<br>冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O（n2）O（n2）（一遍找元素O(n)O(n)，一遍找位置O(n)O(n)）<br>快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)O(nlogn)（一遍找元素O(n)O(n)，一遍找位置O(logn)O(logn)）<br>稳定性记忆-“快希选堆”（快牺牲稳定性）<br>排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。<br>原理理解<br>1 冒泡排序<br>1.1 过程<br>冒泡排序从小到大排序：一开始交换的区间为0<del>N-1，将第1个数和第2个数进行比较，前面大于后面，交换两个数，否则不交换。再比较第2个数和第三个数，前面大于后面，交换两个数否则不交换。依次进行，最大的数会放在数组最后的位置。然后将范围变为0</del>N-2，数组第二大的数会放在数组倒数第二的位置。依次进行整个交换过程，最后范围只剩一个数时数组即为有序。</p>
<p>1.2 动图</p>
<p>1.3 核心代码（函数）<br>//array[]为待排序数组，n为数组长度<br>void BubbleSort(int array[], int n)<br>{<br>    int i, j, k;<br>    for(i=0; i&lt;n-1; i++)<br>        for(j=0; j&lt;n-1-i; j++)<br>        {<br>            if(array[j]&gt;array[j+1])<br>            {<br>                k=array[j];<br>                array[j]=array[j+1];<br>                array[j+1]=k;<br>            }<br>        }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>2 选择排序<br>2.1 过程<br>选择排序从小到大排序：一开始从0<del>n-1区间上选择一个最小值，将其放在位置0上，然后在1</del>n-1范围上选取最小值放在位置1上。重复过程直到剩下最后一个元素，数组即为有序。</p>
<p>2.2 动图</p>
<p>2.3 核心代码（函数）<br>//array[]为待排序数组，n为数组长度<br>void selectSort(int array[], int n)<br>{<br>    int i, j ,min ,k;<br>    for( i=0; i&lt;n-1; i++)<br>    {<br>        min=i; //每趟排序最小值先等于第一个数，遍历剩下的数<br>        for( j=i+1; j&lt;n; j++) //从i下一个数开始检查<br>        {<br>            if(array[min]&gt;array[j])<br>            {<br>                min=j;<br>            }<br>        }<br>        if(min!=i)<br>        {<br>            k=array[min];<br>            array[min]=array[i];<br>            array[i]=k;<br>        }<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>3 插入排序<br>3.1 过程<br>插入排序从小到大排序：首先位置1上的数和位置0上的数进行比较，如果位置1上的数大于位置0上的数，将位置0上的数向后移一位，将1插入到0位置，否则不处理。位置k上的数和之前的数依次进行比较，如果位置K上的数更大，将之前的数向后移位，最后将位置k上的数插入不满足条件点，反之不处理。</p>
<p>3.2 动图</p>
<p>3.3 核心代码（函数）<br>//array[]为待排序数组，n为数组长度<br>void insertSort(int array[], int n)<br>{<br>    int i,j,temp;<br>    for( i=1;i&lt;n;i++)<br>    {<br>        if(array[i]&lt;array[i-1])<br>        {<br>            temp=array[i];<br>            for( j=i;array[j-1]&gt;temp;j–)<br>            {<br>                array[j]=array[j-1];<br>            }<br>            array[j]=temp;<br>        }<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>4 归并排序<br>4.1 过程<br>归并排序从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。</p>
<p>4.2 动图</p>
<p>4.3 核心代码（函数）<br>递归实现<br>////实现归并，并把数据都放在list1里面<br>void merging(int *list1, int list1_size, int *list2,  int list2_size)<br>{<br>    int i=0, j=0, k=0, m=0;<br>    int temp[MAXSIZE];</p>
<pre><code>while(i &lt; list1_size &amp;&amp; j &lt; list2_size)
{
    if(list1[i]&lt;list2[j])
    {
        temp[k++] = list1[i++];
    }
    else
    {
        temp[k++] = list2[j++];
    }
}
while(i&lt;list1_size)
{
    temp[k++] = list1[i++];
}
while(j&lt;list2_size)
{
    temp[k++] = list2[j++];
}

for(m=0; m &lt; (list1_size+list2_size); m++)
{
    list1[m]=temp[m];
}</code></pre><p>}<br>//如果有剩下的，那么说明就是它是比前面的数组都大的，直接加入就可以了<br>void mergeSort(int array[], int n)<br>{<br>    if(n&gt;1)<br>    {<br>        int *list1 = array;<br>        int list1_size = n/2;<br>        int *list2 = array + n/2;<br>        int list2_size = n-list1_size;</p>
<pre><code>    mergeSort(list1, list1_size);
    mergeSort(list2, list2_size);

    merging(list1, list1_size, list2, list2_size);
}</code></pre><p>}<br>//归并排序复杂度分析：一趟归并需要将待排序列中的所有记录<br>//扫描一遍，因此耗费时间为O(n),而由完全二叉树的深度可知，<br>//整个归并排序需要进行[log2n],因此，总的时间复杂度为<br>//O(nlogn),而且这是归并排序算法中平均的时间性能<br>//空间复杂度：由于归并过程中需要与原始记录序列同样数量级的<br>//存储空间去存放归并结果及递归深度为log2N的栈空间，因此空间<br>//复杂度为O(n+logN)<br>//也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>迭代实现<br>void MergeSort(int k[],int n)<br>{<br>    int i,next,left_min,left_max,right_min,right_max;<br>    //动态申请一个与原来数组一样大小的空间用来存储<br>    int <em>temp = (int *)malloc(n * sizeof(int));<br>    //逐级上升，第一次比较2个，第二次比较4个，第三次比较8个。。。<br>    for(i=1; i&lt;n; i</em>=2)<br>    {<br>        //每次都从0开始，数组的头元素开始<br>        for(left_min=0; left_min&lt;n-i; left_min = right_max)<br>        {<br>            right_min = left_max = left_min + i;<br>            right_max = left_max + i;<br>            //右边的下标最大值只能为n<br>            if(right_max&gt;n)<br>            {<br>                right_max = n;<br>            }<br>            //next是用来标志temp数组下标的，由于每次数据都有返回到K，<br>            //故每次开始得重新置零<br>            next = 0;<br>            //如果左边的数据还没达到分割线且右边的数组没到达分割线，开始循环<br>            while(left_min&lt;left_max&amp;&amp;right_min&lt;right_max)<br>            {<br>                if(k[left_min] &lt; k[right_min])<br>                {<br>                    temp[next++] = k[left_min++];<br>                }<br>                else<br>                {<br>                    temp[next++] = k[right_min++];<br>                }<br>            }<br>            //上面循环结束的条件有两个，如果是左边的游标尚未到达，那么需要把<br>            //数组接回去，可能会有疑问，那如果右边的没到达呢，其实模拟一下就可以<br>            //知道，如果右边没到达，那么说明右边的数据比较大，这时也就不用移动位置了  </p>
<pre><code>        while(left_min &lt; left_max)  
        {  
            //如果left_min小于left_max，说明现在左边的数据比较大  
            //直接把它们接到数组的min之前就行  
            k[--right_min] = k[--left_max];   
        }  
        while(next&gt;0)  
        {  
            //把排好序的那部分数组返回该k  
            k[--right_min] = temp[--next];        
        }  
    }  
}  </code></pre><p>}<br>//非递归的方法，避免了递归时深度为log2N的栈空间，<br>//空间只是用到归并临时申请的跟原来数组一样大小的空间，并且在时间性能上也有一定的提升，<br>//因此，使用归并排序是，尽量考虑用非递归的方法。<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>5 快速排序<br>5.1 过程<br>快速排序从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。</p>
<p>5.2 动图</p>
<p>5.3 核心代码（函数）<br>推荐程序（好理解）</p>
<p>//接口调整<br>void adjust_quicksort(int k[],int n)<br>{<br>   quicksort(k,0,n-1);<br>}<br>void quicksort(int a[], int left, int right)<br>{<br>    int i,j,t,temp;<br>    if(left&gt;right)   //（递归过程先写结束条件）<br>       return;  </p>
<pre><code>temp=a[left]; //temp中存的就是基准数  
i=left;  
j=right;  
while(i!=j)  
{  
               //顺序很重要，要先从右边开始找（最后交换基准时换过去的数要保证比基准小，因为基准                               
               //选取数组第一个数，在小数堆中） 
               while(a[j]&gt;=temp &amp;&amp; i&lt;j)  
                        j--;  
               //再找右边的  
               while(a[i]&lt;=temp &amp;&amp; i&lt;j)  
                        i++;  
               //交换两个数在数组中的位置  
               if(i&lt;j)  
               {  
                        t=a[i];  
                        a[i]=a[j];  
                        a[j]=t;  
               }  
}  
//最终将基准数归位 （之前已经temp=a[left]过了，交换只需要再进行两步）
a[left]=a[i];  
a[i]=temp;  

quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程  
quicksort(i+1,right);//继续处理右边的 ，这里是一个递归的过程  </code></pre><p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>6 堆排序<br>6.1 过程<br>堆排序从小到大排序：首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，再将除了最后一个数的n-1个元素建立成大顶堆，再将最大元素和数组倒数第二个元素进行交换，重复直至堆大小减为1。</p>
<p>注：完全二叉树<br>假设二叉树深度为n，除了第n层外，n-1层节点都有两个孩子，第n层节点连续从左到右。如下图 </p>
<p>注：大顶堆<br>大顶堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值。<br>即，根节点是堆中最大的值，按照层序遍历给节点从1开始编号，则节点之间满足如下关系：<br> (1&lt;=i&lt;=n/2)</p>
<p>6.2 动图</p>
<p>6.3 核心代码（函数）</p>
<p>注意！！！数组从1开始，1~n</p>
<p>void heapSort(int array[], int n)<br>{<br>    int i;<br>    for (i=n/2;i&gt;0;i–)<br>    {<br>        HeapAdjust(array,i,n);//从下向上，从右向左调整<br>    }<br>    for( i=n;i&gt;1;i–)<br>    {<br>        swap(array, 1, i);<br>        HeapAdjust(array, 1, i-1);//从上到下，从左向右调整<br>    }<br>}<br>void HeapAdjust(int array[], int s, int n )<br>{<br>    int i,temp;<br>    temp = array[s];<br>    for(i=2<em>s;i&lt;=n;i</em>=2)<br>    {<br>        if(i&lt;n&amp;&amp;array[i]&lt;array[i+1])<br>        {<br>            i++;<br>        }<br>        if(temp&gt;=array[i])<br>        {<br>            break;<br>        }<br>        array[s]=array[i];<br>        s=i;<br>    }<br>    array[s]=temp;<br>}<br>void swap(int array[], int i, int j)<br>{<br>    int temp;</p>
<pre><code>temp=array[i];
array[i]=array[j];
array[j]=temp;</code></pre><p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>7 希尔排序<br>7.1 过程<br>希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。</p>
<p>7.2 动图</p>
<p>7.3 核心程序（函数）<br>//下面是插入排序<br>void InsertSort( int array[], int n)<br>{<br>    int i,j,temp;<br>    for( i=0;i&lt;n;i++ )<br>    {<br>        if(array[i]&lt;array[i-1])<br>        {<br>            temp=array[i];<br>            for( j=i-1;array[j]&gt;temp;j–)<br>            {<br>                array[j+1]=array[j];<br>            }<br>            array[j+1]=temp;<br>        }<br>    }<br>}<br>//在插入排序基础上修改得到希尔排序<br>void SheelSort( int array[], int n)<br>{<br>    int i,j,temp;<br>    int gap=n; //<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    gap=gap/3+1;  //~~~~~~~~~~~~~~~~~~</span><br><span class="line">    for( i=gap;i&lt;n;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        if(array[i]&lt;array[i-gap])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=array[i];</span><br><span class="line">            for( j=i-gap;array[j]&gt;temp;j-=gap)</span><br><span class="line">            &#123;</span><br><span class="line">                array[j+gap]=array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j+gap]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;while(gap&gt;1);  //~</span><br></pre></td></tr></table></figure></p>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>8 桶排序（基数排序和基数排序的思想）<br>8.1 过程<br>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p>
<p>8.2 图解</p>
<p>8.3 核心程序</p>
<p>#include &lt;stdio.h&gt;<br>int main()<br>{<br>    int a[11],i,j,t;<br>    for(i=0;i&lt;=10;i++)<br>        a[i]=0;  //初始化为0</p>
<pre><code>for(i=1;i&lt;=5;i++)  //循环读入5个数
{
    scanf(&quot;%d&quot;,&amp;t);  //把每一个数读到变量t中
    a[t]++;  //进行计数(核心行)
}

for(i=0;i&lt;=10;i++)  //依次判断a[0]~a[10]
    for(j=1;j&lt;=a[i];j++)  //出现了几次就打印几次
        printf(&quot;%d &quot;,i);

getchar();getchar(); 
//这里的getchar();用来暂停程序，以便查看程序输出的内容
//也可以用system(&quot;pause&quot;);等来代替
return 0;</code></pre><p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>9 计数排序<br>9.1 过程<br>算法的步骤如下： </p>
<ul>
<li>找出待排序的数组中最大和最小的元素 </li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项 </li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） </li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ul>
<p>9.2 图解</p>
<p>9.3 核心程序（函数）<br>程序1：</p>
<p>#define NUM_RANGE (100)    //预定义数据范围上限，即K的值</p>
<p>void counting_sort(int <em>ini_arr, int *sorted_arr, int n)  //所需空间为 2</em>n+k<br>{<br>       int *count_arr = (int *)malloc(sizeof(int) * NUM_RANGE);<br>       int i, j, k;  </p>
<pre><code>//初始化统计数组元素为值为零 
for(k=0; k&lt;NUM_RANGE; k++){  
        count_arr[k] = 0;  
}  
//统计数组中，每个元素出现的次数    
for(i=0; i&lt;n; i++){  
        count_arr[ini_arr[i]]++;  
}  

//统计数组计数，每项存前N项和，这实质为排序过程
for(k=1; k&lt;NUM_RANGE; k++){  
        count_arr[k] += count_arr[k-1];  
}  

//将计数排序结果转化为数组元素的真实排序结果
for(j=n-1 ; j&gt;=0; j--){  
    int elem = ini_arr[j];          //取待排序元素
    int index = count_arr[elem]-1;  //待排序元素在有序数组中的序号
    sorted_arr[index] = elem;       //将待排序元素存入结果数组中
    count_arr[elem]--;              //修正排序结果，其实是针对算得元素的修正
}  
free(count_arr);  </code></pre><p>}  </p>
<p>程序2：C++(最大最小压缩桶数)<br>public static void countSort(int[] arr) {<br>        if (arr == null || arr.length &lt; 2) {<br>            return;<br>        }<br>        int min = arr[0];<br>        int max = arr[0];<br>        for (int i = 1; i &lt; arr.length; i++) {<br>            min = Math.min(arr[i], min);<br>            max = Math.max(arr[i], max);<br>        }<br>        int[] countArr = new int[max - min + 1];<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            countArr[arr[i] - min]++;<br>        }<br>        int index = 0;<br>        for (int i = 0; i &lt; countArr.length; i++) {<br>            while (countArr[i]– &gt; 0) {<br>                arr[index++] = i + min;<br>        }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>10 基数排序<br>10.1 过程<br>基数排序是基于数据位数的一种排序算法。<br>它有两种算法<br>①LSD–Least Significant Digit first 从低位（个位）向高位排。<br>②MSD– Most Significant Digit first 从高位向低位（个位）排。<br>时间复杂度O(N*最大位数)。<br>空间复杂度O(N)。</p>
<p>10.2 图解</p>
<p>对a[n]按照个位0~9进行桶排序： </p>
<p>对b[n]进行累加得到c[n]，用于b[n]中重复元素计数<br>！！！b[n]中的元素为temp中的位置！！！跳跃的用++补上： </p>
<p>temp数组为排序后的数组，写回a[n]。temp为按顺序倒出桶中的数据（联合b[n],c[n],a[n]得到），重复元素按顺序输出： </p>
<p>10.3 核心程序<br>//基数排序<br>//LSD  先以低位排，再以高位排<br>//MSD  先以高位排，再以低位排<br>void LSDSort(int <em>a, int n)<br>{<br>    assert(a);  //判断a是否为空，也可以a为空||n&lt;2返回<br>    int digit = 0;   //最大位数初始化<br>    for (int i = 0; i &lt; n; ++i)<br>    {   //求最大位数<br>        while (a[i] &gt; (pow(10,digit)))  //pow函数要包含头文件math.h，pow(10,digit)=10^digit<br>        {<br>            digit++;<br>        }<br>    }<br>    int flag = 1;   //位数<br>    for (int j = 1; j &lt;= digit; ++j)<br>    {<br>        //建立数组统计每个位出现数据次数（Digit[n]为桶排序b[n]）<br>        int Digit[10] = { 0 };<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            Digit[(a[i] / flag)%10]++;  //flag=1时为按个位桶排序<br>        }<br>         //建立数组统计起始下标（BeginIndex[n]为个数累加c[n]，用于记录重复元素位置<br>         //flag=1时，下标代表个位数值，数值代表位置，跳跃代表重复）<br>        int BeginIndex[10] = { 0 };<br>        for (int i = 1; i &lt; 10; ++i)<br>        {<br>            //累加个数<br>            BeginIndex[i] = BeginIndex[i - 1] + Digit[i - 1];<br>        }<br>        //建立辅助空间进行排序<br>        //下面两条可以用calloc函数实现<br>        int *tmp = new int[n];<br>        memset(tmp, 0, sizeof(int)</em>n);//初始化<br>        //联合各数组求排序后的位置存在temp中<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            int index = (a[i] / flag)%10;  //桶排序和位置数组中的下标<br>            //计算temp相应位置对应a[i]中的元素，++为BeginIndex数组数值加1<br>            //跳跃间隔用++来补，先用再++<br>            tmp[BeginIndex[index]++] = a[i];<br>        }<br>        //将数据重新写回原空间<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            a[i] = tmp[i];<br>        }<br>        flag = flag * 10;<br>        delete[] tmp;<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>附：<br>1 完整程序框架（冒泡排序举例）<br>1.1 VS2010程序</p>
<p>#include “stdafx.h”</p>
<p>#include “stdio.h”</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>void BubbleSort(int array[], int n){<br>    int i,j,k,count1=0, count2=0;<br>    for(i=0; i&lt;n-1; i++)<br>        for(j=n-1; j&gt;i; j–)<br>        {<br>            count1++;<br>            if(array[j-1]&gt;array[j])<br>            {<br>                count2++;<br>                k=array[j-1];<br>                array[j-1]=array[j];<br>                array[j]=k;<br>            }<br>        }<br>    printf(“总共的循环次序为：%d,  总共的交换次序为：%d\n\n”, count1, count2);<br>}</p>
<p>int main(int argc, _TCHAR* argv[])<br>{<br>    int as[]={0,1,2,3,4,6,8,5,9,7};<br>    BubbleSort(as, 10);<br>    for(int i=0; i&lt;10; i++)<br>    {<br>        printf(“%d”, as[i]);<br>    }<br>    printf(“\n\n”);<br>    system(“pause”);<br>    return 0;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>1.2 执行程序（OJ）</p>
<p>#include &lt;stdio.h&gt;</p>
<p>void BubbleSort(int array[], int n){<br>    int i,j,k,count1=0, count2=0;<br>    for(i=0; i&lt;n-1; i++)<br>        for(j=n-1; j&gt;i; j–)<br>        {<br>            count1++;<br>            if(array[j-1]&gt;array[j])<br>            {<br>                count2++;<br>                k=array[j-1];<br>                array[j-1]=array[j];<br>                array[j]=k;<br>            }<br>        }<br>    printf(“总共的循环次序为：%d,  总共的交换次序为：%d\n\n”, count1, count2);<br>}</p>
<p>int main()<br>{<br>    int as[]={0,1,2,3,4,6,8,5,9,7};<br>    BubbleSort(as, 10);<br>    int i=0;<br>    for(i=0; i&lt;10; i++)<br>    {<br>        printf(“%d”, as[i]);<br>    }<br>    return 0;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>2 关于交换的优化<br>不用中间变量进行交换</p>
<p>if(A[j] &lt;= A[i]){<br>    A[j] = A[j] + A[i];<br>    A[i] = A[j] - A[i];<br>    A[j] = A[j] - A[i];<br>}<br>1<br>2<br>3<br>4<br>5<br>3 C语言实现数组动态输入</p>
<p>#include &lt;stdio.h&gt;  </p>
<p>#include &lt;assert.h&gt;  //断言头文件</p>
<p>#include &lt;stdlib.h&gt;  </p>
<p>int main(int argc, char const *argv[])<br>{<br>    int size = 0;<br>    scanf(“%d”, &amp;size);   //首先输入数组个数<br>    assert(size &gt; 0);     //判断数组个数是否非法</p>
<pre><code>int *array = (int *)calloc(size, sizeof(int));  //动态分配数组
if(!R1)  
{  
    return;           //申请空间失败  
}  

int i = 0;  
for (i = 0; i &lt; size; ++i) {  
    scanf(&quot;%d&quot;, &amp;array[i]);  
}  

mergeSort(array, size);  
printArray(array, size);  

free(array);  
return 0;  </code></pre><p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>注：<br>1.colloc与malloc类似,但是主要的区别是存储在已分配的内存空间中的值默认为0,使用malloc时,已分配的内存中可以是任意的值. </p>
<h2 id="2-colloc需要两个参数-第一个是需要分配内存的变量的个数-第二个是每个变量的大小"><a href="#2-colloc需要两个参数-第一个是需要分配内存的变量的个数-第二个是每个变量的大小" class="headerlink" title="2.colloc需要两个参数,第一个是需要分配内存的变量的个数,第二个是每个变量的大小."></a>2.colloc需要两个参数,第一个是需要分配内存的变量的个数,第二个是每个变量的大小.</h2>
    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://yoursite.com"></a>
            <p>原文链接：<a href="http://yoursite.com/passages/java杂记/排序算法时间复杂度、空间复杂度、稳定性比较/">http://yoursite.com/passages/java杂记/排序算法时间复杂度、空间复杂度、稳定性比较/</a>
            <p>发表日期：<a href="http://yoursite.com/passages/java杂记/排序算法时间复杂度、空间复杂度、稳定性比较/">July 8th 2019, 7:51:36 pm</a>
            <p>更新日期：<a href="http://yoursite.com/passages/java杂记/排序算法时间复杂度、空间复杂度、稳定性比较/">July 7th 2019, 12:58:32 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/passages/java杂记/基础算法java/" title= "java基础算法">
                    <div class="nextTitle">java基础算法</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/passages/三次握手，四次挥手/" title= "三次握手四次挥手详解">
                    <div class="prevTitle">三次握手四次挥手详解</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:853664702@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/yizhenxiao/" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/20190704122728.jpg" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-colloc需要两个参数-第一个是需要分配内存的变量的个数-第二个是每个变量的大小"><span class="toc-number">1.</span> <span class="toc-text">2.colloc需要两个参数,第一个是需要分配内存的变量的个数,第二个是每个变量的大小.</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 21
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/passages/springboot笔记/了解springboot基础/" >SpringBoot笔记</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href= "/passages/Linux/Linux最常用命令：简单易学，但能解决95%以上的问题/" >Linux最常用命令：简单易学，但能解决95%以上的问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href= "/passages/常见面试题回答攻略/程序员面试硬软技能/" >[Untitled Post]</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/10</span><a class="archive-post-title" href= "/passages/Mybatis笔记/数据库事务详解/" >MySQL-事务详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span><a class="archive-post-title" href= "/passages/java杂记/排序算法时间复杂度、空间复杂度、稳定性比较/" >排序算法时间复杂度、空间复杂度、稳定性比较</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span><a class="archive-post-title" href= "/passages/三次握手，四次挥手/" >三次握手四次挥手详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/05</span><a class="archive-post-title" href= "/passages/java快速排序/" >Java快速排序</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/passages/Mybatis笔记/Mybatis_day01/" >Mybatis笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/passages/maven笔记/maven_day01/" >Maven 简述</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/passages/spring笔记/1、spring原理/" >Spring原理</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/passages/maven笔记/Maven 核心原理/" >Maven 核心原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/passages/java杂记/面向切面编程/" >面向切面编程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/passages/JDBC笔记/JDBC/" >JDBC简述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/passages/java杂记/面向对象编程/" >面向对象编程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/passages/java杂记/工厂模式/" >工厂模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/passages/README/" >first blog</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/passages/springboot笔记/springboot深入解读/" >[Untitled Post]</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/passages/Struts2笔记/strust_day01/" >Struts2笔记</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/passages/要成为一个高效的丶合理的决策者，你必须：/" >成为一个高效的丶合理的决策者</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/passages/java杂记/基础算法java/" >java基础算法</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/passages/spring笔记/springday01/" >spring笔记</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: ""
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


