{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"Struts2笔记/strust_day01","date":"2019-07-04T10:11:30.663Z","updated":"2019-07-04T10:50:21.181Z","comments":true,"path":"passages/Struts2笔记/strust_day01/","link":"","permalink":"http://yoursite.com/passages/Struts2笔记/strust_day01/","excerpt":"","text":"title： Struts2笔记 strust2框架：概述：​ 是一个基于MVC设计模式的WEB层框架。 常见的web层框架​ struts2 ​ struts2 ​ springMVC ​ Webwork Web层框架基于前端控制器模型设计​ ![图一 前端控制器模型](D:\\学习很重要\\学习\\javaweb全套\\07-Struts2框架（学习4天）\\day01_Strust入门XML配置-action编写\\资料\\图一 前端控制器模型.bmp)","categories":[],"tags":[]},{"title":"","slug":"spring笔记/springday01","date":"2019-07-04T10:11:30.644Z","updated":"2019-06-30T16:20:31.058Z","comments":true,"path":"passages/spring笔记/springday01/","link":"","permalink":"http://yoursite.com/passages/spring笔记/springday01/","excerpt":"","text":"spring:​ 概述：EE开发的 一站式 框架 ​ 一站式框架 ：有EE开发的每一层的解决方案。 ​ WEB层 ：SpringMVC ​ Service : Spring的bean管理，Spring声明式事务 ​ DAO层（持久层）： Spring 的 JDBC 模板，Spring的 ORM ​ IOC:(Inversion of Control 控制反转)​ Spring底层的IOC的实现原理：​ 工厂+反射+配置文件 –》实现程序解耦合 *&lt; bean id=”UserDAO” class=”xxx.UserDAOImpl”&gt; class BeanFactory{ ​ public static Object getBean(String id){ ​ //解析XML ​ //反射 ​ Class clazz=Class.forName(); ​ return clazz.newInstance(); ​ } } DI(依赖注入)：​ 前提必须有IOC的环境，spring管理这个类的时候将类的依赖的属性注入（设置）进来。 面向对象：依赖：​ class A{ } ​ class B{ ​ public void xxx(A a){ //B依赖了A ​ } } 继承: is a​ class A{ } ​ class B extends A{ } 聚合: has a​ bean:​ 标签： ​ id ：使用了约束中的唯一约束，里面不能出现特殊字符的。 ​ name：没有使用约束中的唯一约束（理论上可以出现重复的，但实际开发并不能出现的）。可以出现特殊字段 ​ class：对应的是要生成实例的类的全路径 ​ 作用范围的配置：（重点） ​ scope ：Bean的作用范围 ​ *singleton ：默认：Spring会用单列模式创建这个对象。* ​ *prototype ：多例模式。* ​ request ：应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。 ​ session ：应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。 ​ globalsession ：应用在web项目中，必须在prolet环境下使用。但是如果没有这种环境，相对于session。","categories":[],"tags":[]},{"title":"","slug":"spring笔记/1、spring原理","date":"2019-07-04T10:11:30.638Z","updated":"2019-07-04T10:49:45.483Z","comments":true,"path":"passages/spring笔记/1、spring原理/","link":"","permalink":"http://yoursite.com/passages/spring笔记/1、spring原理/","excerpt":"","text":"title： spring笔记 1、spring原理​ 内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。 Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过 配置类达到的。 Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象） 要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。Spring里用的最经典的一个设计模式就是：模板方法模式。(这里我都不介绍了，是一个很常用的设计模式)， Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了 也就基本上掌握了Spring.Spring AOP与IOC一、 IoC(Inversion of control): 控制反转1、IoC：概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系核心：bean工厂；在Spring中，bean工厂创建的各个实例称作bean二、AOP(Aspect-Oriented Programming): 面向方面编程1、 代理的两种方式：静态代理： 针对每个具体类分别编写代理类； 针对一个接口编写一个代理类；动态代理：针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类 2、动态代理:不用写代理类，虚拟机根据真实对象实现的接口产生一个类，通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。 ​ 1、产生动态代理的类: ​ java.lang.refect.Proxy ​ 2、装备必须实现InvocationHandler接口实现invoke方法 3、反射​ 什么是类的返射? ​ 通过类说明可以得到类的父类、实现的接口、内部类、构造函数、方法、属性并可以根据构造器实例化一个对象，唤起一个方法，取属性值，改属性值。如何得到一个类说明： ​ Class cls=类.class; ​ Class cls=对象.getClass(); ​ Class.forName(“类路径”); ​ 如何得到一个方法并唤起它? ​ Class cls=类.class; ​ Constructor cons=cls.getConstructor(new Class[]{String.class}); ​ Object obj=cons.newInstance(new Object[]{“aaa”}); ​ Method method=cls.getMethod(“方法名”,new Class[]{String.class,Integer.class}); ​ method.invoke(obj,new Object[]{“aa”,new Integer(1)}); 4、spring的三种注入方式是什么?​ setter ​ interface ​ constructor 5、spring的核心接口及核心配置文件是什么?​ FactoryBean:工厂bean主要实现ioc/di ​ ApplicationContext ac=new FileXmlApplicationContext(“applicationContext.xml”); ​ Object obj=ac.getBean(“id值”); 6、Spring框架的7个模块 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： ​ 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 ​ Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 ​ Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 ​ Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 ​ Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 ​ Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 ​ Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。","categories":[],"tags":[]},{"title":"","slug":"springboot笔记/了解springboot基础","date":"2019-07-04T10:11:30.615Z","updated":"2019-07-04T10:49:10.373Z","comments":true,"path":"passages/springboot笔记/了解springboot基础/","link":"","permalink":"http://yoursite.com/passages/springboot笔记/了解springboot基础/","excerpt":"","text":"title： springboot笔记 SpringBoot:​ 概述：其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 简介：​ SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决 。 特点SpringBoot所具备的特征有： （1）可以创建独立的Spring应用程序，并且基于其Maven或Grandel插件，可以创建可执行的JARs和WARs； （2）内嵌Tomcat或Jetty等Servlet容器； （3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置； （4）尽可能自动配置Spring容器； （5）提供准备好的特性，如指标、健康检查和外部化配置； （6）绝对没有代码生成，不需要XML配置。 重要策略​ SpringBoot框架中还有两个非常重要的策略：开箱即用 和 约定优于配置。开箱即用，Outofbox，是指在开发过程中，通过在MAVEN项目的pom文件中添加相关依赖包，然后使用对应注解来代替繁琐的XML配置文件以管理对象的生命周期。这个特点使得开发人员摆脱了复杂的配置工作以及依赖的管理工作，更加专注于业务逻辑。约定优于配置，Convention over configuration，是一种由SpringBoot本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了BUG定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的XML配置，并且可以将代码编译、测试和打包等工作自动化。 SpringBoot应用系统开发模板的基本架构设计从前端到后台进行说明：前端常使用模板引擎，主要有FreeMarker和Thymeleaf，它们都是用Java语言编写的，渲染模板并输出相应文本，使得界面的设计与应用的逻辑分离，同时前端开发还会使用到Bootstrap、AngularJS、JQuery等；在浏览器的数据传输格式上采用Json，非xml，同时提供RESTfulAPI；SpringMVC框架用于数据到达服务器后处理请求；到数据访问层主要有Hibernate、MyBatis、JPA等持久层框架；数据库常用MySQL；开发工具推荐IntelliJIDEA。","categories":[],"tags":[]},{"title":"","slug":"springboot笔记/springboot深入解读","date":"2019-07-04T10:11:30.614Z","updated":"2019-07-04T05:43:01.171Z","comments":true,"path":"passages/springboot笔记/springboot深入解读/","link":"","permalink":"http://yoursite.com/passages/springboot笔记/springboot深入解读/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Mybatis笔记/Mybatis_day01","date":"2019-07-04T10:11:30.597Z","updated":"2019-07-04T10:48:24.339Z","comments":true,"path":"passages/Mybatis笔记/Mybatis_day01/","link":"","permalink":"http://yoursite.com/passages/Mybatis笔记/Mybatis_day01/","excerpt":"","text":"title： Mybatis笔记 Mybatis:（类似于hibernate的持久层框架）​ 概述：持久层框架 ​ MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 每个MyBatis应用程序主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactoryBuilder可以从一个xml配置文件或者一个预定义的配置类的实例获得。 用xml文件构建SqlSessionFactory实例是非常简单的事情。推荐在这个配置中使用类路径资源（classpath resource)，但你可以使用任何Reader实例，包括用文件路径或file://开头的url创建的实例。MyBatis有一个实用类—-Resources，它有很多方法，可以方便地从类路径及其它位置加载资源。 持久层框架编辑 Hibernate Hibernate [1] 是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。Eclipse平台下的Hibernate辅助开发工具:【Hibernate Synchronizer】【MiddlegenIDE】 MyBatis 使用MyBatis 提供的ORM机制，对业务逻辑实现人员而言，面对的是纯粹的Java对象， 这一层与通过Hibernate 实现ORM 而言基本一致，而对于具体的数据操作，Hibernate 会自动生成SQL 语句，而MyBatis则要求开发者编写具体的SQL 语句。相对Hibernate等 “全自动”ORM机制而言，MyBatis 以SQL开发的工作量和数据库移植性上的让步，为系统 设计提供了更大的自由空间。作为“全自动”ORM 实现的一种有益补充，MyBatis 的出现显 得别具意义。 -","categories":[],"tags":[]},{"title":"","slug":"maven笔记/maven_day01","date":"2019-07-04T10:11:30.572Z","updated":"2019-06-29T04:54:36.163Z","comments":true,"path":"passages/maven笔记/maven_day01/","link":"","permalink":"http://yoursite.com/passages/maven笔记/maven_day01/","excerpt":"","text":"maven：（说白了就是对jar包的管理并给出坐标的过程）​ 概述：项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。 Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长","categories":[],"tags":[]},{"title":"","slug":"maven笔记/Maven 核心原理","date":"2019-07-04T10:11:30.569Z","updated":"2019-06-30T08:58:17.192Z","comments":true,"path":"passages/maven笔记/Maven 核心原理/","link":"","permalink":"http://yoursite.com/passages/maven笔记/Maven 核心原理/","excerpt":"","text":"Maven 核心原理标签 ： Java基础 Maven 是每一位Java工程师每天都会接触的工具, 但据我所知其实很多人对Maven理解的并不深, 只把它当做一个依赖管理工具(下载依赖、打包), Maven很多核心的功能反而没用上. 最近重读 Maven实战, 虽然这本书年岁较老(10年出版: 那还是Hudson年代), 但绝大部分还是很值得参考的. 本文讲述Maven的核心原理和概念, 因此还是大纲参考了这本书, 但细节大多参考的Maven的官方文档以及网友释出的博客. 本文主要讲解Maven的: 坐标与依赖、仓库、生命周期与插件、模块聚合、模块继承等概念, 并通过一个开发Maven插件的实例来深入了解Maven的核心机制. 而对于 如何配置Maven、Nexus私服、Jenkins持续集成、Maven测试、构建Web、资源过滤、自定义Archetype 等相对简单、讲解繁琐且网上有大量实践案例的内容没有涉及. 本文的目标是希望读者能够通过本文能对Maven核心原理有个相对深入的理解. 坐标与依赖为了能够自动化地解析任何一个Java构件, Maven必须将它们唯一标识, 这就是依赖管理的底层基础-坐标. 坐标在数学中, 任何一个坐标可以唯一确定一个“点”. Maven 坐标为Java构件引入了秩序, 任何一个构件都必须明确定义自己的坐标, 坐标元素包括groupId、artifactId、version、packaging、classfier: org.apache.commonscommons-lang33.4jar1234元素 描述 extgroupId 定义当前模块隶属的实际Maven项目, 表示方式与Java包类似 groupId不应直接对应项目隶属的公司/组织(一个公司/组织下可能会有很多的项目).artifactId 定义实际项目中的一个Maven模块 推荐使用项目名作为artifactId前缀, 如:commons-lang3以commons作为前缀(因为Maven打包默认以artifactId作为前缀)version 定义当前项目所处版本(如1.0-SNAPSHOT、4.2.7.RELEASE、1.2.15、14.0.1-h-3 等) Maven版本号定义约定: &lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;里程碑版本&gt;packaging 定义Maven项目打包方式, 通常打包方式与所生成构件扩展名对应 有jar(默认)、war、pom、maven-plugin等.classifier 用来帮助定义构建输出的一些附属构件(如javadoc、sources) 不能直接定义项目的classifier(因为附属构件不是由项目默认生成, 须有附加插件的帮助)依赖Maven最著名的(也是几乎每个人最先接触到的)就是Maven的依赖管理, 它使得我们不必再到开源项目的官网一个个下载开源组件, 然后再一个个放入classpath. 一个依赖声明可以包含如下元素: org.springframework spring-web 4.2.7.RELEASE &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 依赖传递 Maven依赖传递机制会自动加载我们引入的依赖包的依赖, 而不必去手动指定(好拗口(⊙﹏⊙)b : This allows you to avoid needing to discover and specify the libraries that your own dependencies require, and including them automatically). 如: 我们的项目依赖了spring-core, 而spring-core又依赖了commons-logging: 有了依赖传递机制, 在项目中添加了spring-core依赖时就不用再去考虑它依赖了什么, 也不用担心引入多余的依赖. Maven会解析各个直接依赖的POM, 将必要的间接依赖以传递性依赖的形式引入到当前目录中(inherits from its parents, or from its dependencies, and so on).(依赖调节原则: 1. 路径最近者优先; 2. 第一声明者优先.)更多传递依赖信息可参考: Dependency Mechanism-Transitive Dependencies. 声明一个或者多个项目依赖, 可以包含的元素有: 元素 描述 ExtgroupId、artifactId和version 依赖的基本坐标(最最重要)type 依赖的类型, 对应于项目坐标定义的packaging 默认jarscope 依赖的范围, 用来控制依赖与三种classpath(编译classpath、测试classpath、运行classpath)的关系 包含compile、provided、runtime、test、system和import 6种, 详见:Dependency Scope.optional 依赖是否可选 假如一个Jar包支持MySQL与Oracle两种DB, 因此其构建时必须添加两类驱动, 但用户使用时只会选择一种DB. 此时对A、B就可使用optional可选依赖exclusions 排除传递性依赖 传递性依赖极大的简化了项目依赖的管理, 但也会引入Jar包版本冲突等问题, 此时就需要对传递性依赖进行排除. optional与exclusions详细可参考: Optional Dependencies and Dependency Exclusions依赖管理Maven提供了dependency插件可以对Maven项目依赖查看以及优化, 如$ mvn dependency:tree可以查看当前项目的依赖树, 详见$ mvn dependency:help.Maven 仓库Maven 中, 任何一个依赖、插件或项目构建的输出, 都可称为构件, 而Maven仓库就是集中存储这些构件的地方. 两类仓库Maven仓库可简单分成两类: 本地仓库与远程仓库. 当Maven根据坐标寻找构件时, 它会首先检索本地仓库, 如果本地存在则直接使用, 否则去远程仓库下载. 本地仓库: 默认地址为~/.m2/, 一个构件只有在本地仓库存在之后, 才能由Maven项目使用.远程仓库: 远程仓库又可简单分成两类: 中央仓库和私服.由于原始的本地仓库是空的, Maven必须至少知道一个远程仓库才能在执行命令时下载需要的构件, 中央仓库就是这样一个默认的远程仓库.关于仓库的详细配置可参考: Settings Reference 的 Servers、Mirrors、Profiles 等章节. 私服 私服是一种特殊的远程仓库, 它设在局域网内, 通过代理广域网上的远程仓库, 供局域网内的Maven用户使用.当需要下载构件时, Maven客户端先向私服请求, 如果私服不存在该构件, 则从外部的远程仓库下载, 并缓存在私服上, 再为客户提供下载服务. 此外, 一些无法从外部仓库下载到的构建也能从本地上传到私服供大家使用(如公司内部二方包、Oracle的JDBC启动等). 为了节省带宽和时间, 一般在公司内部都会架设一台Maven私服, 但将公司内部项目部署到私服还需要对POM做如下配置: ... releases http://mvn.server.com/nexus/content/repositories/releases/ snapshots http://mvn.server.com/nexus/content/repositories/snapshots/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 repository表示发布版本构件的仓库, snapshotRepository代表快照版本的仓库. id为该远程仓库唯一标识, url表示该仓库地址. 配置正确后, 执行$ mvn clean deploy则可以将项目构建输出的构件部署到对应配置的远程仓库. 注: 往远程仓库部署构件时, 往往需要认证: 需要在settings.xml中创建servers元素, 其id与仓库的id匹配, 详见: Password Encryption. 仓库搜索推荐几个可用的Maven仓库搜索服务:MVNrepository: http://mvnrepository.com/Sonatype Nexus: https://repository.sonatype.org/生命周期与插件Maven 将所有项目的构建过程统一抽象成一套生命周期: 项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成 … 几乎所有项目的构建,都能映射到这一组生命周期上. 但生命周期是抽象的(Maven的生命周期本身是不做任何实际工作), 任务执行(如编译源代码)均交由插件完成. 其中每个构建步骤都可以绑定一个或多个插件的目标,而且Maven为大多数构建步骤都编写并绑定了默认插件.当用户有特殊需要的时候, 也可以配置插件定制构建行为, 甚至自己编写插件. 生命周期Maven 拥有三套相互独立的生命周期: clean、default 和 site, 而每个生命周期包含一些phase阶段, 阶段是有顺序的, 并且后面的阶段依赖于前面的阶段. 而三套生命周期相互之间却并没有前后依赖关系, 即调用site周期内的某个phase阶段并不会对clean产生任何影响. cleanclean生命周期的目的是清理项目: 执行如$ mvn clean; defaultdefault生命周期定义了真正构建时所需要执行的所有步骤: 执行如$ mvn clean install; sitesite生命周期的目的是建立和发布项目站点: Maven能够基于POM所包含的信息,自动生成一个友好的站点,方便团队交流和发布项目信息 执行命令如$ mvn clean deploy site-deploy; 更多 Maven 生命周期介绍可以参考: Introduction to the Build Lifecycle、Lifecycles Reference. 插件生命周期的阶段phase与插件的目标goal相互绑定, 用以完成实际的构建任务. 而对于插件本身, 为了能够复用代码,它往往能够完成多个任务, 这些功能聚集在一个插件里,每个功能就是一个目标.如:$ mvn compiler:compile: 冒号前是插件前缀, 后面是该插件目标(即: maven-compiler-plugin的compile目标).而该目标绑定了default生命周期的compile阶段: 因此, 他们的绑定能够实现项目编译的目的. 内置绑定为了能让用户几乎不用任何配置就能使用Maven构建项目, Maven 默认为一些核心的生命周期绑定了插件目标, 当用户通过命令调用生命周期阶段时, 对应的插件目标就会执行相应的逻辑. clean生命周期阶段绑定生命周期阶段 插件目标pre-clean -clean maven-clean-plugin:cleanpost-clean -default声明周期阶段绑定生命周期阶段 插件目标 执行任务process-resources maven-resources-plugin:resources 复制主资源文件到主输出目录compile maven-compiler-plugin:compile 编译主代码到主输出目录process-test-resources maven-resources-plugin:testResources 复制测试资源文件到测试输出目录test-compile maven-compiler-plugin:testCompile 编译测试代码到测试输出目录test maven-surefire-plugin:test 执行测试用例package maven-jar-plugin:jar 打jar包install maven-install-plugin:install 将项目输出安装到本地仓库deploy maven-deploy-plugin:deploy 将项目输出部署到远程仓库注: 上表只列出了打包方式为jar且拥有插件绑定关系的阶段, 其他打包类型生命周期的默认绑定关系可参考: Built-in Lifecycle Bindings、Plugin Bindings for default Lifecycle Reference. site生命周期阶段绑定生命周期阶段 插件目标pre-site -site maven-site-plugin:sitepost-site -site-deploy maven-site-plugin:deploy自定义绑定除了内置绑定以外, 用户还能够自定义将某个插件目标绑定到生命周期的某个阶段上. 如创建项目的源码包, maven-source-plugin插件的jar-no-fork目标能够将项目的主代码打包成jar文件, 可以将其绑定到verify阶段上: org.apache.maven.plugins maven-source-plugin 3.0.0 attach-sources verify jar-no-fork 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 executions下每个execution子元素可以用来配置执行一个任务. 关于Maven插件的自定义绑定及其他详细配置可参考: Guide to Configuring Plug-ins. 插件查询在线Maven 官方插件https://maven.apache.org/plugins/index.htmlCodeHaus 插件http://www.mojohaus.org/plugins.htmlmaven-help-pluginmvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin[:3.0.0] [-Ddetail] [-Dgoal=jar-no-fork]1聚合与继承Maven的聚合特性(aggregation)能够使项目的多个模块聚合在一起构建, 而继承特性(inheritance)能够帮助抽取各模块相同的依赖、插件等配置,在简化模块配置的同时, 保持各模块一致. 模块聚合随着项目越来越复杂(需要解决的问题越来越多、功能越来越重), 我们更倾向于将一个项目划分几个模块并行开发, 如: 将feedcenter-push项目划分为client、core和web三个模块, 而我们又想一次构建所有模块, 而不是针对各模块分别执行$ mvn命令. 于是就有了Maven的模块聚合 -&gt; 将feedcenter-push作为聚合模块将其他模块聚集到一起构建: 聚合POM聚合模块POM仅仅是帮助聚合其他模块构建的工具, 本身并无实质内容: &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;feedcenter-push-client&lt;/module&gt; &lt;module&gt;feedcenter-push-core&lt;/module&gt; &lt;module&gt;feedcenter-push-web&lt;/module&gt; &lt;/modules&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 通过在一个打包方式为pom的Maven项目中声明任意数量的module以实现模块聚合: packaging: pom, 否则无法聚合构建. modules: 实现聚合的核心,module值为被聚合模块相对于聚合POM的相对路径, 每个被聚合模块下还各自包含有pom.xml、src/main/java、src/test/java等内容, 离开聚合POM也能够独立构建(注: 模块所处目录最好与其artifactId一致). Tips: 推荐将聚合POM放在项目目录的最顶层, 其他模块作为聚合模块的子目录. 其他关于聚合与反应堆介绍可参考: Guide to Working with Multiple Modules. 模块继承在面向对象中, 可以通过类继承实现复用. 在Maven中同样也可以创建POM的父子结构, 通过在父POM中声明一些配置供子POM继承来实现复用与消除重复: 父POM与聚合类似, 父POM的打包方式也是pom, 因此可以继续复用聚合模块的POM(这也是在开发中常用的方式): &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;feedcenter-push-client&lt;/module&gt; &lt;module&gt;feedcenter-push-core&lt;/module&gt; &lt;module&gt;feedcenter-push-web&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;finalName&gt;feedcenter-push&lt;/finalName&gt; &lt;warName&gt;${finalName}.war&lt;/warName&gt; &lt;spring.version&gt;4.0.6.RELEASE&lt;/spring.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;warExplodedDirectory&gt;exploded/${warName}&lt;/warExplodedDirectory&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 dependencyManagement: 能让子POM继承父POM的配置的同时, 又能够保证子模块的灵活性: 在父POMdependencyManagement元素配置的依赖声明不会实际引入子模块中, 但能够约束子模块dependencies下的依赖的使用(子模块只需配置groupId与artifactId, 见下). pluginManagement: 与dependencyManagement类似, 配置的插件不会造成实际插件的调用行为, 只有当子POM中配置了相关plugin元素, 才会影响实际的插件行为. 2. 子POM &lt;parent&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;feedcenter-push-client&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 元素继承 可以看到, 子POM中并未定义模块groupId与version, 这是因为子POM默认会从父POM继承了如下元素: groupId、versiondependenciesdevelopers and contributorsplugin lists (including reports)plugin executions with matching idsplugin configurationresources因此所有的springframework都省去了version、junit还省去了scope, 而且插件还省去了executions与configuration配置, 因为完整的声明已经包含在父POM中.优势: 当依赖、插件的版本、配置等信息在父POM中声明之后, 子模块在使用时就无须声明这些信息, 也就不会出现多个子模块使用的依赖版本不一致的情况, 也就降低了依赖冲突的几率. 另外如果子模块不显式声明依赖与插件的使用, 即使已经在父POM的dependencyManagement、pluginManagement中配置了, 也不会产生实际的效果. 推荐: 模块继承与模块聚合同时进行,这意味着, 你可以为你的所有模块指定一个父工程, 同时父工程中可以指定其余的Maven模块作为它的聚合模块. 但需要遵循以下三条规则: 在所有子POM中指定它们的父POM;将父POM的packaging值设为pom;在父POM中指定子模块/子POM的目录.注: parent元素内还包含一个relativePath元素, 用于指定父POM的相对路径, 默认../pom.xml. 超级pom-约定优先于配置任何一个Maven项目都隐式地继承自超级POM, 因此超级POM的大量配置都会被所有的Maven项目继承, 这些配置也成为了Maven所提倡的约定. 4.0.0 central Central Repository https://repo.maven.apache.org/maven2 default false central Central Repository https://repo.maven.apache.org/maven2 default false never ${project.basedir}/target ${project.build.directory}/classes ${project.artifactId}-${project.version} ${project.build.directory}/test-classes ${project.basedir}/src/main/java ${project.basedir}/src/main/scripts ${project.basedir}/src/test/java ${project.basedir}/src/main/resources ${project.basedir}/src/test/resources &lt;!-- 为核心插件设定版本 --&gt; &lt;pluginManagement&gt; &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt; &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.2-beta-5&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; ${project.build.directory}/site release-profile &lt;activation&gt; &lt;property&gt; &lt;name&gt;performRelease&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 附: Maven继承与组合的其他信息还可参考: Introduction to the POM. Maven Plugin 开发几乎100%的场景都不用我们自己开发Maven插件, 但理解插件开发可以使我们更加深入的理解Maven. 下面我们实际开发一个用于统计代码行数的插件 lc-maven-plugin. 创建plugin项目mvn archetype:generate -DgroupId=com.fq.plugins -DartifactId=lc-maven-plugin -Dversion=0.0.1-SNAPSHOT -DarchetypeArtifactId=maven-archetype-plugin -DinteractiveMode=false -DarchetypeCatalog=internal12345使用maven-archetype-plugin Archetype可以快速创建一个Maven插件项目(关于Maven Archetype可参考What is an Archetype 、Creating Archetypes[注: 该文档介绍的是Archetype 1.x编写, 2.x内附链接]). pom.xml插件本身也是Maven项目, 特殊之处在于packaging方式为maven-plugin: &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fq.plugins&lt;/groupId&gt; &lt;artifactId&gt;lc-maven-plugins&lt;/artifactId&gt; &lt;packaging&gt;maven-plugin&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven.plugin-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-plugin-annotations&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 maven-plugin 打包方式能控制Maven为其在生命周期阶段绑定插件处理的相关目标. 编写目标MojoWhat is a Mojo? A mojo is a M aven plain O ld J ava O bject. Each mojo is an executable goal in Maven, and a plugin is a distribution of one or more related mojos. /** @author jifang @since 16/10/9 上午11:33. */ @Mojo(name = “lc”, defaultPhase = LifecyclePhase.VERIFY) public class LCMavenMojo extends AbstractMojo { private static final List DEFAULT_FILES = Arrays.asList(“java”, “xml”, “properties”); @Parameter(defaultValue = “${project.basedir}”, readonly = true) private File baseDir; @Parameter(defaultValue = “${project.build.sourceDirectory}”, readonly = true) private File srcDir; @Parameter(defaultValue = “${project.build.testSourceDirectory}”, readonly = true) private File testSrcDir; @Parameter(defaultValue = “${project.build.resources}”, readonly = true) private List resources; @Parameter(defaultValue = “${project.build.testResources}”, readonly = true) private List testResources; @Parameter(property = “lc.file.includes”) private Set includes = new HashSet&lt;&gt;(); private Log logger = getLog(); @Override public void execute() throws MojoExecutionException, MojoFailureException { if (includes.isEmpty()) { logger.debug(&quot;includes/lc.file.includes is empty!&quot;); includes.addAll(DEFAULT_FILES); } logger.info(&quot;includes: &quot; + includes); try { long lines = 0; lines += countDir(srcDir); lines += countDir(testSrcDir); for (Resource resource : resources) { lines += countDir(new File(resource.getDirectory())); } for (Resource resource : testResources) { lines += countDir(new File(resource.getDirectory())); } logger.info(&quot;total lines: &quot; + lines); } catch (IOException e) { logger.error(&quot;error: &quot;, e); throw new MojoFailureException(&quot;execute failure: &quot;, e); } } private LineProcessor lp = new LineProcessor() { private long line = 0; @Override public boolean processLine(String fileLine) throws IOException { if (!Strings.isNullOrEmpty(fileLine)) { ++this.line; } return true; } @Override public Long getResult() { long result = line; this.line = 0; return result; } }; private long countDir(File directory) throws IOException { long lines = 0; if (directory.exists()) { Set&lt;File&gt; files = new HashSet&lt;&gt;(); collectFiles(files, directory); for (File file : files) { lines += CharStreams.readLines(new FileReader(file), lp); } String path = directory.getAbsolutePath().substring(baseDir.getAbsolutePath().length()); logger.info(&quot;path: &quot; + path + &quot;, file count: &quot; + files.size() + &quot;, total line: &quot; + lines); logger.info(&quot;\\t-&gt; files: &quot; + files.toString()); } return lines; } private void collectFiles(Set&lt;File&gt; files, File file) { if (file.isFile()) { String fileName = file.getName(); int index = fileName.lastIndexOf(&quot;.&quot;); if (index != -1 &amp;&amp; includes.contains(fileName.substring(index + 1))) { files.add(file); } } else { File[] subFiles = file.listFiles(); for (int i = 0; subFiles != null &amp;&amp; i &lt; subFiles.length; ++i) { collectFiles(files, subFiles[i]); } } }}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@Parameter: 配置点, 提供Mojo的可配置参数. 大部分Maven插件及其目标都是可配置的, 通过配置点, 用户可以自定义插件行为: com.fq.plugins lc-maven-plugins 0.0.1-SNAPSHOT lc verify lc java lua json xml properties 1234567891011121314151617181920212223execute(): 实际插件功能;异常: execute()方法可以抛出以下两种异常:MojoExecutionException: Maven执行目标遇到该异常会显示 BUILD FAILURE 错误信息, 表示在运行期间发生了预期的错误;MojoFailureException: 表示运行期间遇到了未预期的错误, 显示 BUILD ERROR 信息. 测试&amp;执行通过mvn clean install将插件安装到仓库后, 就可将其配置到实际Maven项目中, 用于统计项目代码了: $ mvn com.fq.plugins:lc-maven-plugins:0.0.1-SNAPSHOT:lc [-Dlc.file.includes=js,lua] [-X]1注: 其他关于Maven Plugin开发可参考:Plugin Developers Centre、Maven API Reference. 参考 &amp; 扩展Maven实战持续部署, 并不简单maven.apache.orgGuide to creating assembliesMaven入门指南（一）用 Maven 做项目构建项目管理: Maven 让事情变得简单Maven开始逃离 XML 阵营Apache Maven JDeps插件3.0.0版本发布Maven实战（六）——Gradle，构建工具的未来？Maven实战（七）——常用Maven插件介绍（上）Maven实战（八）——常用Maven插件介绍（下）Maven实战（九）——打包的技巧 Gradle 2.0发布：简单、快速、支持Java 8作者：菜鸟-翡青来源：CSDN原文：https://blog.csdn.net/zjf280441589/article/details/53044308/版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[],"tags":[]},{"title":"","slug":"JDBC笔记/JDBC","date":"2019-07-04T10:11:30.566Z","updated":"2019-07-04T10:47:00.133Z","comments":true,"path":"passages/JDBC笔记/JDBC/","link":"","permalink":"http://yoursite.com/passages/JDBC笔记/JDBC/","excerpt":"","text":"title： JDBC JDBC:（Java data base Connectivity (java数据库连接)）​ 是一种执行SQL语句的javaAPI，可以为多种关系数据库提供统一访问，它由一组用java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 ​ JDBC连接数据库步骤：1.加载驱动 2.连接数据库 3.使用语句操作数据库 4.关闭数据库连接，释放资源 ##","categories":[],"tags":[]},{"title":"面向对象编程","slug":"java杂记/面向对象编程","date":"2019-07-04T10:11:30.563Z","updated":"2019-07-04T10:45:25.254Z","comments":true,"path":"passages/java杂记/面向对象编程/","link":"","permalink":"http://yoursite.com/passages/java杂记/面向对象编程/","excerpt":"","text":"面向对象编程：概述​ 面向对象程序设计（Object OrientedProgramming，OOP）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。 面向对象程序设计方法是尽可能模拟人类的思维方式，使得软件的开发方法与过程尽可能接近人类认识世界、解决现实问题的方法和过程，也即使得描述问题的问题空间与问题的解决方案空间在结构上尽可能一致，把客观世界中的实体抽象为问题域中的对象。 面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，对象是类的实例化。对象间通过消息传递相互通信，来模拟现实世界中不同实体间的联系。在面向对象的程序设计中，对象是组成程序的基本模块。 特点1、封装性： 封装是指将一个计算机系统中的数据以及与这个数据相关的一切操作语言（即描述每一个对象的属性以及其行为的程序代码）组装到一起，一并封装在一个有机的实体中，把它们封装在一个“模块”中，也就是一个类中，为软件结构的相关部件所具有的模块性提供良好的基础。在面向对象技术的相关原理以及程序语言中，封装的最基本单位是对象，而使得软件结构的相关部件的实现“高内聚、低耦合”的“最佳状态”便是面向对象技术的封装性所需要实现的最基本的目标。对于用户来说，对象是如何对各种行为进行操作、运行、实现等细节是不需要刨根问底了解清楚的，用户只需要通过封装外的通道对计算机进行相关方面的操作即可。大大地简化了操作的步骤，使用户使用起计算机来更加高效、更加得心应手。 2、继承性： 继承性是面向对象技术中的另外一个重要特点，其主要指的是两种或者两种以上的类之间的联系与区别。继承，顾名思义，是后者延续前者的某些方面的特点，而在面向对象技术则是指一个对象针对于另一个对象的某些独有的特点、能力进行复制或者延续。如果按照继承源进行划分，则可以分为单继承（一个对象仅仅从另外一个对象中继承其相应的特点）与多继承（一个对象可以同时从另外两个或者两个以上的对象中继承所需要的特点与能力，并且不会发生冲突等现象）；如果从继承中包含的内容进行划分，则继承可以分为四类，分别为取代继承（一个对象在继承另一个对象的能力与特点之后将父对象进行取代）、包含继承（一个对象在将另一个对象的能力与特点进行完全的继承之后，又继承了其他对象所包含的相应内容，结果导致这个对象所具有的能力与特点大于等于父对象，实现了对于父对象的包含）、受限继承、特化继承。 3、多态性： 从宏观的角度来讲，多态性是指在面向对象技术中，当不同的多个对象同时接收到同一个完全相同的消息之后，所表现出来的动作是各不相同的，具有多种形态；从微观的角度来讲，多态性是指在一组对象的一个类中，面向对象技术可以使用相同的调用方式来对相同的函数名进行调用，即便这若干个具有相同函数名的函数所表示的函数是不同的。 [2]","categories":[],"tags":[]},{"title":"","slug":"java杂记/面向切面编程","date":"2019-07-04T10:11:30.561Z","updated":"2019-07-04T10:46:01.005Z","comments":true,"path":"passages/java杂记/面向切面编程/","link":"","permalink":"http://yoursite.com/passages/java杂记/面向切面编程/","excerpt":"","text":"title: 面向切面编程 ### 面向切面编程：​ Aspect Oriented Programming(AOP)，面向切面编程，是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。比如我们最常见的就是日志记录了，举个例子，我们现在提供一个查询学生信息的服务，但是我们希望记录有谁进行了这个查询。如果按照传统的OOP的实现的话，那我们实现了一个查询学生信息的服务接口(StudentInfoService)和其实现 类 （StudentInfoServiceImpl.java），同时为了要进行记录的话，那我们在实现类(StudentInfoServiceImpl.java)中要添加其实现记录的过程。这样的话，假如我们要实现的服务有多个呢？那就要在每个实现的类都添加这些记录过程。这样做的话就会有点繁琐，而且每个实现类都与记录服务日志的行为紧耦合，违反了面向对象的规则。那么怎样才能把记录服务的行为与业务处理过程中分离出来呢？看起来好像就是查询学生的服务自己在进行，但却是背后日志记录对这些行为进行记录，并且查询学生的服务不知道存在这些记录过程，这就是我们要讨论AOP的目的所在。AOP的编程，好像就是把我们在某个方面的功能提出来与一批对象进行隔离，这样与一批对象之间降低了耦合性，可以就某个功能进行编程。","categories":[],"tags":[]},{"title":"工厂模式","slug":"java杂记/工厂模式","date":"2019-07-04T10:11:30.559Z","updated":"2019-07-04T10:44:28.583Z","comments":true,"path":"passages/java杂记/工厂模式/","link":"","permalink":"http://yoursite.com/passages/java杂记/工厂模式/","excerpt":"","text":"工厂方法模式概述：​ 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。 优点：​ 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有代码，后期维护容易，增强了系统的扩展性 缺点：​ 需要额外的编写代码，增加了工作量 案例：","categories":[],"tags":[]},{"title":"成为一个高效的丶合理的决策者","slug":"要成为一个高效的丶合理的决策者，你必须：","date":"2019-07-04T02:27:43.626Z","updated":"2019-07-04T04:12:56.879Z","comments":true,"path":"passages/要成为一个高效的丶合理的决策者，你必须：/","link":"","permalink":"http://yoursite.com/passages/要成为一个高效的丶合理的决策者，你必须：/","excerpt":"","text":"要成为一个高效的丶合理的决策者，你必须：1.制定出最根本的目标和需求，并反复说出来以提醒自己。你所作出的决策应该有助于自己扫除障碍，为实现目标丶满足需求而创造机会。2.无论何时，都要逐个解决问题，做出决策，并尽可能清楚丶准确地陈述当前情形和其他备选决策。3.仔细研究备选决策所处的环境，搞清楚自己要做的决策，并认清楚每种备选决策可能产生的后果。要区分清楚：哪些决策你可以主动控制，而哪些决策是强加与你的。把精力集中在那些最重要的以及你可以施加最大影响的决策上。4.确认你需要哪些信息，并主动寻找它们。5.认真分析并解释收集到的信息，得出合理推论。6.确认自己可以有哪些行动。短期内你能做什么？长期呢？看到自己在金钱丶时间和权力上存在哪些不足。7.评价你在这种情况下可以做出的选择，充分考虑每种选择的优缺点。8.根据所做决策采取相应的策略，并按这种策略行事，包括立即行动或者谨慎的观望策略。9.行动时，一旦后果开始出现，就要对它进行监控。如果情况需要，要随时准备好修改自己的策略，随着你掌握的信息越来越多，要准备好改变自己的策略丶分析或者对决策种类的描述。","categories":[],"tags":[]},{"title":"first blog","slug":"README","date":"2019-07-03T16:00:25.064Z","updated":"2019-07-04T04:40:53.549Z","comments":true,"path":"passages/README/","link":"","permalink":"http://yoursite.com/passages/README/","excerpt":"","text":"Hello yierA brand new default theme for Hexo. Preview InstallationInstall1$ git clone https://github.com/hexojs/hexo-theme-landscape.git themes/landscape Landscape requires Hexo 2.4 and above. If you would like to enable the RSS, the hexo-generate-feed plugin is also required. EnableModify theme setting in _config.yml to landscape. Update12cd themes/landscapegit pull Configuration123456789101112131415161718192021222324# Headermenu: Home: / Archives: /archivesrss: /atom.xml# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- category- tag- tagcloud- archives- recent_posts# Miscellaneousgoogle_analytics:favicon: /favicon.pngtwitter:google_plus: menu - Navigation menu rss - RSS link excerpt_link - “Read More” link at the bottom of excerpted articles. false to hide the link. fancybox - Enable Fancybox sidebar - Sidebar style. You can choose left, right, bottom or false. widgets - Widgets displaying in sidebar google_analytics - Google Analytics ID favicon - Favicon path twitter - Twiiter ID google_plus - Google+ ID FeaturesFancyboxLandscape uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting. Landscape provides 5 built-in widgets: category tag tagcloud archives recent_posts All of them are enabled by default. You can edit them in widget setting. DevelopmentRequirements Grunt 0.4+ Hexo 2.4+ Grunt tasks default - Download Fancybox and Font Awesome. fontawesome - Only download Font Awesome. fancybox - Only download Fancybox. clean - Clean temporarily files and downloaded files.","categories":[],"tags":[]}]}