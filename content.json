{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"MySQL-事务详解","slug":"Mybatis笔记/数据库事务详解","date":"2019-07-10T15:02:00.044Z","updated":"2019-07-10T14:59:55.041Z","comments":true,"path":"passages/Mybatis笔记/数据库事务详解/","link":"","permalink":"http://yoursite.com/passages/Mybatis笔记/数据库事务详解/","excerpt":"","text":"一、事务定义Transaction事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同二、转账操作理解事务关于银行账户转账操作，账户转账是一个完整的业务，最小的单元，不可再分————————也就是说银行账户转账是一个事务以下是银行账户表t_act(账号、余额)，进行转账操作actno balance1 5002 100123转账操作update t_act set balance=400 where actno=1;update t_act set balance=200 where actno=2;12以上两台DML语句必须同时成功或者同时失败。最小单元不可再分，当第一条DML语句执行成功后，并不能将底层数据库中的第一个账户的数据修改，只是将操作记录了一下；这个记录是在内存中完成的；当第二条DML语句执行成功后，和底层数据库文件中的数据完成同步。若第二条DML语句执行失败，则清空所有的历史操作记录，要完成以上的功能必须借助事务 三、事务四大特征(ACID)原子性(A)：事务是最小单位，不可再分一致性(C)：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败隔离性(I)：事务A和事务B之间具有隔离性持久性(D)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)四、关于事务的一些术语开启事务：Start Transaction事务结束：End Transaction提交事务：Commit Transaction回滚事务：Rollback Transaction五、和事务相关的两条重要的SQL语句(TCL)commit:提交rollback：回滚六、事务开启的标志？事务结束的标志？开启标志： 任何一条DML语句(insert、update、delete)执行，标志事务的开启1结束标志(提交或者回滚)： 提交：成功的结束，将所有的DML语句操作历史记录和底层硬盘数据来一次同步 回滚：失败的结束，将所有的DML语句操作历史记录全部清空12七、事物与数据库底层数据在事物进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据 八、在MySQL中，事务提交与回滚在MySQL中，默认情况下，事务是自动提交的，也就是说，只要执行一条DML语句就开启了事物，并且提交了事务 以上的自动提交机制是可以关闭的对t_user进行提交和回滚操作提交操作(事务成功)start transactionDML语句commit mysql&gt; start transaction;#手动开启事务mysql&gt; insert into t_user(name) values(‘pp’);mysql&gt; commit;#commit之后即可改变底层数据库数据mysql&gt; select * from t_user;+—-+——+| id | name |+—-+——+| 1 | jay || 2 | man || 3 | pp |+—-+——+3 rows in set (0.00 sec)123456789101112回滚操作(事务失败)start transactionDML语句rollback mysql&gt; start transaction;mysql&gt; insert into t_user(name) values(‘yy’);mysql&gt; rollback;mysql&gt; select * from t_user;+—-+——+| id | name |+—-+——+| 1 | jay || 2 | man || 3 | pp |+—-+——+3 rows in set (0.00 sec)123456789101112九、事务四大特性之一————隔离性(isolation)事物A和事物B之间具有一定的隔离性隔离性有隔离级别(4个)读未提交：read uncommitted读已提交：read committed可重复读：repeatable read串行化：serializable1、 read uncommitted 事物A和事物B，事物A未提交的数据，事物B可以读取到 这里读取到的数据叫做“脏数据” 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别1232、read committed 事物A和事物B，事物A提交的数据，事物B才能读取到 这种隔离级别高于读未提交 换句话说，对方事物提交之后的数据，我当前事物才能读取到 这种级别可以避免“脏数据” 这种隔离级别会导致“不可重复读取” Oracle默认隔离级别1234563、repeatable read 事务A和事务B，事务A提交之后的数据，事务B读取不到 事务B是可重复读取数据 这种隔离级别高于读已提交 换句话说，对方提交之后的数据，我还是读取不到 这种隔离级别可以避免“不可重复读取”，达到可重复读取 比如1点和2点读到数据是同一个 MySQL默认级别 虽然可以达到可重复读取，但是会导致“幻像读”123456784、serializable 事务A和事务B，事务A在操作数据库时，事务B只能排队等待 这种隔离级别很少使用，吞吐量太低，用户体验差 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发123十、隔离级别与一致性关系 十一、设置事务隔离级别方式一可以在my.ini文件中使用transaction-isolation选项来设置服务器的缺省事务隔离级别。 该选项值可以是： – READ-UNCOMMITTED– READ-COMMITTED– REPEATABLE-READ– SERIALIZABLE • 例如：[mysqld]transaction-isolation = READ-COMMITTED12345678方式二通过命令动态设置隔离级别• 隔离级别也可以在运行的服务器中动态设置，应使用SET TRANSACTION ISOLATION LEVEL语句。• 其语法模式为： SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL &lt;isolation-level&gt; 其中的&lt;isolation-level&gt;可以是： – READ UNCOMMITTED – READ COMMITTED – REPEATABLE READ – SERIALIZABLE • 例如： SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;1234567十二、隔离级别的作用范围• 事务隔离级别的作用范围分为两种：– 全局级：对所有的会话有效– 会话级：只对当前的会话有效• 例如，设置会话级隔离级别为READ COMMITTED ：mysql&gt; SET TRANSACTION ISOLATION LEVEL READ COMMITTED；或：mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED；• 设置全局级隔离级别为READ COMMITTED ：mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED；123456789十三、查看隔离级别• 事务隔离级别的作用范围分为两种：– 全局级：对所有的会话有效– 会话级：只对当前的会话有效• 例如，设置会话级隔离级别为READ COMMITTED ：mysql&gt; SET TRANSACTION ISOLATION LEVEL READ COMMITTED；或：mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED；• 设置全局级隔离级别为READ COMMITTED ： mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED；","categories":[],"tags":[]},{"title":"java基础算法","slug":"java杂记/基础算法java","date":"2019-07-08T11:51:57.636Z","updated":"2019-07-08T11:56:10.098Z","comments":true,"path":"passages/java杂记/基础算法java/","link":"","permalink":"http://yoursite.com/passages/java杂记/基础算法java/","excerpt":"","text":"查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中。因为其实现代码较短，应用较常见。所以在面试中经常会问到排序算法及其相关的问题。但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。一般在面试中最常考的是快速排序和归并排序，并且经常有面试官要求现场写出这两种排序的代码。对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。 面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。 接下来我们就分析一下常见的排序算法及其使用场景。限于篇幅，某些算法的详细演示和图示请自行寻找详细的参考。 冒泡排序冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** *@Description:冒泡排序算法实现 */public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; for(int i=0; i) &#123; for(int j=arr.length-1; j&gt;i; j--) &#123; if(arr[j]&lt;arr[j-1]) &#123; swap(arr, j-1, j); &#125; &#125; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 抑或简单理解一点的正向排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class BubbleSort &#123; public static void bubbleSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; for(int i=1;i&lt;arr.length-1;i++) &#123; for(int j=0; j&gt;arr.length-i; j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; swap(arr, j+1, j); &#125; &#125; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 选择排序选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** *@Description:简单选择排序算法的实现 */public class SelectSort &#123; public static void selectSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int minIndex = 0; for(int i=0; i//只需要比较n-1次 minIndex = i; for(int j=i+1; j//从i+1开始比较，因为minIndex默认为i了，i就没必要比了。 if(arr[j] arr[minIndex]) &#123; minIndex = j; &#125; &#125; if(minIndex != i) &#123; //如果minIndex不为i，说明找到了更小的值，交换之。 swap(arr, i, minIndex); &#125; &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; 插入排序插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** *@Description:简单插入排序算法实现 */public class InsertSort &#123; public static void insertSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; for(int i=1; i//假设第一个数位置时正确的；要往后移，必须要假设第一个。 int j = i; int target = arr[i]; //待插入的 //后移 while(j &gt; 0 &amp; target ]) &#123; arr[j] = arr[j-1]; j --; &#125; //插入 arr[j] = target; &#125; &#125; &#125; 快速排序快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。快速排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。 举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。 5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。 5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。 5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。 4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。 上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。 快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/** *@Description:实现快速排序算法 */public class QuickSort &#123; //一次划分 public static int partition(int[] arr, int left, int right) &#123; int pivotKey = arr[left]; int pivotPointer = left; while(left right) &#123; while(left = pivotKey) right --; while(left pivotKey) left ++; swap(arr, left, right); //把大的交换到右边，把小的交换到左边。 &#125; swap(arr, pivotPointer, left); //最后把pivot交换到中间 return left; &#125; public static void quickSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); &#125; public static void sort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); &#125; public static void swap(int[] arr, int left, int right) &#123; int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125; &#125; 其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/** *@Description:实现快速排序算法 */public class QuickSort &#123; /** * 划分 * @param arr * @param left * @param right * @return */ public static int partition(int[] arr, int left, int right) &#123; int pivotKey = arr[left]; while(left right) &#123; while(left = pivotKey) right --; arr[left] = arr[right]; //把小的移动到左边 while(left pivotKey) left ++; arr[right] = arr[left]; //把大的移动到右边 &#125; arr[left] = pivotKey; //最后把pivot赋值到中间 return left; &#125; /** * 递归划分子序列 * @param arr * @param left * @param right */ public static void quickSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); &#125; public static void sort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); &#125; &#125; 总结快速排序的思想：冒泡+二分+递归分治，慢慢体会。。。 堆排序堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。 首先，实现堆排序需要解决两个问题： 12345如何由一个无序序列键成一个堆？如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？ 第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。 第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。 从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子： 49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下： 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217/** *@Description:堆排序算法的实现，以大顶堆为例。 */public class HeapSort &#123; /** * 堆筛选，除了start之外，start~end均满足大顶堆的定义。 * 调整之后start~end称为一个大顶堆。 * @param arr 待调整数组 * @param start 起始指针 * @param end 结束指针 */ public static void heapAdjust(int[] arr, int start, int end) &#123; int temp = arr[start]; for(int i=2*start+1; i) &#123; //左右孩子的节点分别为2*i+1,2*i+2 //选择出左右孩子较小的下标 if(i ]) &#123; i ++; &#125; if(temp &gt;= arr[i]) &#123; break; //已经为大顶堆，=保持稳定性。 &#125; arr[start] = arr[i]; //将子节点上移 start = i; //下一轮筛选 &#125; arr[start] = temp; //插入正确的位置 &#125; public static void heapSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; //建立大顶堆 for(int i=arr.length/2; i&gt;=0; i--) &#123; heapAdjust(arr, i, arr.length-1); &#125; for(int i=arr.length-1; i&gt;=0; i--) &#123; swap(arr, 0, i); heapAdjust(arr, 0, i-1); &#125; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; 希尔排序希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。 举个栗子： 从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。 希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** *@Description:希尔排序算法实现 */public class ShellSort &#123; /** * 希尔排序的一趟插入 * @param arr 待排数组 * @param d 增量 */ public static void shellInsert(int[] arr, int d) &#123; for(int i=d; i) &#123; int j = i - d; int temp = arr[i]; //记录要插入的数据 while (j&gt;=0 &amp; arr[j]&gt;temp) &#123; //从后向前，找到比其小的数的位置 arr[j+d] = arr[j]; //向后挪动 j -= d; &#125; if (j != i - d) //存在比其小的数 arr[j+d] = temp; &#125; &#125; public static void shellSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int d = arr.length / 2; while(d &gt;= 1) &#123; shellInsert(arr, d); d /= 2; &#125; &#125; &#125; 归并排序归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。 举个栗子： 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245/** *@Description:归并排序算法的实现 */public class MergeSort &#123; public static void mergeSort(int[] arr) &#123; mSort(arr, 0, arr.length-1); &#125; /** * 递归分治 * @param arr 待排数组 * @param left 左指针 * @param right 右指针 */ public static void mSort(int[] arr, int left, int right) &#123; if(left &gt;= right) return ; int mid = (left + right) / 2; mSort(arr, left, mid); //递归排序左边 mSort(arr, mid+1, right); //递归排序右边 merge(arr, left, mid, right); //合并 &#125; /** * 合并两个有序数组 * @param arr 待合并数组 * @param left 左指针 * @param mid 中间指针 * @param right 右指针 */ public static void merge(int[] arr, int left, int mid, int right) &#123; //[left, mid] [mid+1, right] int[] temp = new int[right - left + 1]; //中间数组 int i = left; int j = mid + 1; int k = 0; while(i right) &#123; if(arr[i] arr[j]) &#123; temp[k++] = arr[i++]; &#125; else &#123; temp[k++] = arr[j++]; &#125; &#125; while(i mid) &#123; temp[k++] = arr[i++]; &#125; while(j right) &#123; temp[k++] = arr[j++]; &#125; for(int p=0; p) &#123; arr[left + p] = temp[p]; &#125; &#125;&#125; 计数排序如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/** *@Description:计数排序算法实现 */public class CountSort &#123; public static void countSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int max = max(arr); int[] count = new int[max+1]; Arrays.fill(count, 0); for(int i=0; i) &#123; count[arr[i]] ++; &#125; int k = 0; for(int i=0; i) &#123; for(int j=0; j) &#123; arr[k++] = i; &#125; &#125; &#125; public static int max(int[] arr) &#123; int max = Integer.MIN_VALUE; for(int ele : arr) &#123; if(ele &gt; max) max = ele; &#125; return max; &#125; &#125; 桶排序桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。 对桶排序的分析和解释借鉴这位兄弟的文章（有改动）：http://hxraid.iteye.com/blog/647759 桶排序的基本思想： 假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1 举个栗子： 假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。 桶排序分析： 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。 对N个关键字进行桶排序的时间复杂度分为两个部分： (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。 (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点： (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。 (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为： O(N)+O(M(N/M)log(N/M))=O(N+N(logN-logM))=O(N+NlogN-N*logM) 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。 总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/** *@Description:桶排序算法实现 */public class BucketSort &#123; public static void bucketSort(int[] arr) &#123; if(arr == null &amp; arr.length == 0) return ; int bucketNums = 10; //这里默认为10，规定待排数[0,100) List&gt; buckets = new ArrayList&gt;(); //桶的索引 for(int i=0; i) &#123; buckets.add(new LinkedList()); //用链表比较合适 &#125; //划分桶 for(int i=0; i) &#123; buckets.get(f(arr[i])).add(arr[i]); &#125; //对每个桶进行排序 for(int i=0; i) &#123; if(!buckets.get(i).isEmpty()) &#123; Collections.sort(buckets.get(i)); //对每个桶进行快排 &#125; &#125; //还原排好序的数组 int k = 0; for(List bucket : buckets) &#123; for(int ele : bucket) &#123; arr[k++] = ele; &#125; &#125; &#125; /** * 映射函数 * @param x * @return */ public static int f(int x) &#123; return x / 10; &#125; &#125; 基数排序基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。 举个栗子： 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325/** *@Description:基数排序算法实现 */public class RadixSort &#123; public static void radixSort(int[] arr) &#123; if(arr == null &amp; arr.length == 0) return ; int maxBit = getMaxBit(arr); for(int i=1; i) &#123; List&gt; buf = distribute(arr, i); //分配 collecte(arr, buf); //收集 &#125; &#125; /** * 分配 * @param arr 待分配数组 * @param iBit 要分配第几位 * @return */ public static List&gt; distribute(int[] arr, int iBit) &#123; List&gt; buf = new ArrayList&gt;(); for(int j=0; j) &#123; buf.add(new LinkedList()); &#125; for(int i=0; i) &#123; buf.get(getNBit(arr[i], iBit)).add(arr[i]); &#125; return buf; &#125; /** * 收集 * @param arr 把分配的数据收集到arr中 * @param buf */ public static void collecte(int[] arr, List&gt; buf) &#123; int k = 0; for(List bucket : buf) &#123; for(int ele : bucket) &#123; arr[k++] = ele; &#125; &#125; &#125; /** * 获取最大位数 * @param x * @return */ public static int getMaxBit(int[] arr) &#123; int max = Integer.MIN_VALUE; for(int ele : arr) &#123; int len = (ele+&quot;&quot;).length(); if(len &gt; max) max = len; &#125; return max; &#125; /** * 获取x的第n位，如果没有则为0. * @param x * @param n * @return */ public static int getNBit(int x, int n) &#123; String sx = x + &quot;&quot;; if(sx.length() n) return 0; else return sx.charAt(sx.length()-n) - &apos;0&apos;; &#125; &#125; 总结 在前面的介绍和分析中我们提到了冒泡排序、选择排序、插入排序三种简单的排序及其变种快速排序、堆排序、希尔排序三种比较高效的排序。后面我们又分析了基于分治递归思想的归并排序还有计数排序、桶排序、基数排序三种线性排序。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。 下面就总结一下排序算法的各自的使用场景和适用场合。 1234567891011121314151617181920212223242526272829从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。 上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。 基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。 附：基于比较排序算法时间下限为O(nlogn)的证明： 基于比较排序下限的证明是通过决策树证明的，决策树的高度Ω（nlgn），这样就得出了比较排序的下限。 首先要引入决策树。 首先决策树是一颗二叉树，每个节点表示元素之间一组可能的排序，它予以京进行的比较相一致，比较的结果是树的边。 先来说明一些二叉树的性质，令T是深度为d的二叉树，则T最多有2^片树叶。 具有L片树叶的二叉树的深度至少是logL。 所以，对n个元素排序的决策树必然有n!片树叶（因为n个数有n!种不同的大小关系），所以决策树的深度至少是log(n!)，即至少需要log(n!)次比较。 而 log(n!)=logn+log(n-1)+log(n-2)+…+log2+log1 &gt;=logn+log(n-1)+log(n-2)+…+log(n/2) &gt;=(n/2)log(n/2) &gt;=(n/2)logn-n/2 =O(nlogn) 所以只用到比较的排序算法最低时间复杂度是O(nlogn)。","categories":[],"tags":[]},{"title":"排序算法时间复杂度、空间复杂度、稳定性比较","slug":"java杂记/排序算法时间复杂度、空间复杂度、稳定性比较","date":"2019-07-08T11:51:36.300Z","updated":"2019-07-07T04:58:32.390Z","comments":true,"path":"passages/java杂记/排序算法时间复杂度、空间复杂度、稳定性比较/","link":"","permalink":"http://yoursite.com/passages/java杂记/排序算法时间复杂度、空间复杂度、稳定性比较/","excerpt":"","text":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/yushiyi6453/article/details/76407640排序算法分类 排序算法比较表格填空排序算法 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定冒泡排序 :————-: :—–: :—–: :—–:选择排序 :————-: :—–: :—–: :—–:直接插入排序 :————-: :—–: :—–: :—–:归并排序 :————-: :—–: :—–: :—–:快速排序 :————-: :—–: :—–: :—–:堆排序 :————-: :—–: :—–: :—–:希尔排序 :————-: :—–: :—–: :—–:计数排序 :————-: :—–: :—–: :—–:基数排序 :————-: :—–: :—–: :—–:排序算法比较表格排序算法 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定冒泡排序 O（n2）O（n2） O（n2）O（n2） O（1）O（1） 是选择排序 O（n2）O（n2） O（n2）O（n2） O（1）O（1） 不是直接插入排序 O（n2）O（n2） O（n2）O（n2） O（1）O（1） 是归并排序 O(nlogn)O(nlogn) O(nlogn)O(nlogn) O（n）O（n） 是快速排序 O(nlogn)O(nlogn) O（n2）O（n2） O（logn）O（logn） 不是堆排序 O(nlogn)O(nlogn) O(nlogn)O(nlogn) O（1）O（1） 不是希尔排序 O(nlogn)O(nlogn) O（ns）O（ns） O（1）O（1） 不是计数排序 O(n+k)O(n+k) O(n+k)O(n+k) O(n+k)O(n+k) 是基数排序 O(N∗M)O(N∗M) O(N∗M)O(N∗M) O(M)O(M) 是注：1 归并排序可以通过手摇算法将空间复杂度降到O（1），但是时间复杂度会提高。2 基数排序时间复杂度为O（N*M），其中N为数据个数，M为数据位数。辅助记忆时间复杂度记忆-冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O（n2）O（n2）（一遍找元素O(n)O(n)，一遍找位置O(n)O(n)）快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)O(nlogn)（一遍找元素O(n)O(n)，一遍找位置O(logn)O(logn)）稳定性记忆-“快希选堆”（快牺牲稳定性）排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。原理理解1 冒泡排序1.1 过程冒泡排序从小到大排序：一开始交换的区间为0N-1，将第1个数和第2个数进行比较，前面大于后面，交换两个数，否则不交换。再比较第2个数和第三个数，前面大于后面，交换两个数否则不交换。依次进行，最大的数会放在数组最后的位置。然后将范围变为0N-2，数组第二大的数会放在数组倒数第二的位置。依次进行整个交换过程，最后范围只剩一个数时数组即为有序。 1.2 动图 1.3 核心代码（函数）//array[]为待排序数组，n为数组长度void BubbleSort(int array[], int n){ int i, j, k; for(i=0; i&lt;n-1; i++) for(j=0; j&lt;n-1-i; j++) { if(array[j]&gt;array[j+1]) { k=array[j]; array[j]=array[j+1]; array[j+1]=k; } }}1234567891011121314152 选择排序2.1 过程选择排序从小到大排序：一开始从0n-1区间上选择一个最小值，将其放在位置0上，然后在1n-1范围上选取最小值放在位置1上。重复过程直到剩下最后一个元素，数组即为有序。 2.2 动图 2.3 核心代码（函数）//array[]为待排序数组，n为数组长度void selectSort(int array[], int n){ int i, j ,min ,k; for( i=0; i&lt;n-1; i++) { min=i; //每趟排序最小值先等于第一个数，遍历剩下的数 for( j=i+1; j&lt;n; j++) //从i下一个数开始检查 { if(array[min]&gt;array[j]) { min=j; } } if(min!=i) { k=array[min]; array[min]=array[i]; array[i]=k; } }}123456789101112131415161718192021223 插入排序3.1 过程插入排序从小到大排序：首先位置1上的数和位置0上的数进行比较，如果位置1上的数大于位置0上的数，将位置0上的数向后移一位，将1插入到0位置，否则不处理。位置k上的数和之前的数依次进行比较，如果位置K上的数更大，将之前的数向后移位，最后将位置k上的数插入不满足条件点，反之不处理。 3.2 动图 3.3 核心代码（函数）//array[]为待排序数组，n为数组长度void insertSort(int array[], int n){ int i,j,temp; for( i=1;i&lt;n;i++) { if(array[i]&lt;array[i-1]) { temp=array[i]; for( j=i;array[j-1]&gt;temp;j–) { array[j]=array[j-1]; } array[j]=temp; } }}12345678910111213141516174 归并排序4.1 过程归并排序从小到大排序：首先让数组中的每一个数单独成为长度为1的区间，然后两两一组有序合并，得到长度为2的有序区间，依次进行，直到合成整个区间。 4.2 动图 4.3 核心代码（函数）递归实现////实现归并，并把数据都放在list1里面void merging(int *list1, int list1_size, int *list2, int list2_size){ int i=0, j=0, k=0, m=0; int temp[MAXSIZE]; while(i &lt; list1_size &amp;&amp; j &lt; list2_size) { if(list1[i]&lt;list2[j]) { temp[k++] = list1[i++]; } else { temp[k++] = list2[j++]; } } while(i&lt;list1_size) { temp[k++] = list1[i++]; } while(j&lt;list2_size) { temp[k++] = list2[j++]; } for(m=0; m &lt; (list1_size+list2_size); m++) { list1[m]=temp[m]; }}//如果有剩下的，那么说明就是它是比前面的数组都大的，直接加入就可以了void mergeSort(int array[], int n){ if(n&gt;1) { int *list1 = array; int list1_size = n/2; int *list2 = array + n/2; int list2_size = n-list1_size; mergeSort(list1, list1_size); mergeSort(list2, list2_size); merging(list1, list1_size, list2, list2_size); }}//归并排序复杂度分析：一趟归并需要将待排序列中的所有记录//扫描一遍，因此耗费时间为O(n),而由完全二叉树的深度可知，//整个归并排序需要进行[log2n],因此，总的时间复杂度为//O(nlogn),而且这是归并排序算法中平均的时间性能//空间复杂度：由于归并过程中需要与原始记录序列同样数量级的//存储空间去存放归并结果及递归深度为log2N的栈空间，因此空间//复杂度为O(n+logN)//也就是说，归并排序是一种比较占内存，但却效率高且稳定的算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455迭代实现void MergeSort(int k[],int n){ int i,next,left_min,left_max,right_min,right_max; //动态申请一个与原来数组一样大小的空间用来存储 int temp = (int *)malloc(n * sizeof(int)); //逐级上升，第一次比较2个，第二次比较4个，第三次比较8个。。。 for(i=1; i&lt;n; i=2) { //每次都从0开始，数组的头元素开始 for(left_min=0; left_min&lt;n-i; left_min = right_max) { right_min = left_max = left_min + i; right_max = left_max + i; //右边的下标最大值只能为n if(right_max&gt;n) { right_max = n; } //next是用来标志temp数组下标的，由于每次数据都有返回到K， //故每次开始得重新置零 next = 0; //如果左边的数据还没达到分割线且右边的数组没到达分割线，开始循环 while(left_min&lt;left_max&amp;&amp;right_min&lt;right_max) { if(k[left_min] &lt; k[right_min]) { temp[next++] = k[left_min++]; } else { temp[next++] = k[right_min++]; } } //上面循环结束的条件有两个，如果是左边的游标尚未到达，那么需要把 //数组接回去，可能会有疑问，那如果右边的没到达呢，其实模拟一下就可以 //知道，如果右边没到达，那么说明右边的数据比较大，这时也就不用移动位置了 while(left_min &lt; left_max) { //如果left_min小于left_max，说明现在左边的数据比较大 //直接把它们接到数组的min之前就行 k[--right_min] = k[--left_max]; } while(next&gt;0) { //把排好序的那部分数组返回该k k[--right_min] = temp[--next]; } } } }//非递归的方法，避免了递归时深度为log2N的栈空间，//空间只是用到归并临时申请的跟原来数组一样大小的空间，并且在时间性能上也有一定的提升，//因此，使用归并排序是，尽量考虑用非递归的方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545 快速排序5.1 过程快速排序从小到大排序：在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边，大于此数的放在右边，再对数组两边递归调用快速排序，重复这个过程。 5.2 动图 5.3 核心代码（函数）推荐程序（好理解） //接口调整void adjust_quicksort(int k[],int n){ quicksort(k,0,n-1);}void quicksort(int a[], int left, int right){ int i,j,t,temp; if(left&gt;right) //（递归过程先写结束条件） return; temp=a[left]; //temp中存的就是基准数 i=left; j=right; while(i!=j) { //顺序很重要，要先从右边开始找（最后交换基准时换过去的数要保证比基准小，因为基准 //选取数组第一个数，在小数堆中） while(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; //再找右边的 while(a[i]&lt;=temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if(i&lt;j) { t=a[i]; a[i]=a[j]; a[j]=t; } } //最终将基准数归位 （之前已经temp=a[left]过了，交换只需要再进行两步） a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的 ，这里是一个递归的过程 }12345678910111213141516171819202122232425262728293031323334353637386 堆排序6.1 过程堆排序从小到大排序：首先将数组元素建成大小为n的大顶堆，堆顶（数组第一个元素）是所有元素中的最大值，将堆顶元素和数组最后一个元素进行交换，再将除了最后一个数的n-1个元素建立成大顶堆，再将最大元素和数组倒数第二个元素进行交换，重复直至堆大小减为1。 注：完全二叉树假设二叉树深度为n，除了第n层外，n-1层节点都有两个孩子，第n层节点连续从左到右。如下图 注：大顶堆大顶堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值。即，根节点是堆中最大的值，按照层序遍历给节点从1开始编号，则节点之间满足如下关系： (1&lt;=i&lt;=n/2) 6.2 动图 6.3 核心代码（函数） 注意！！！数组从1开始，1~n void heapSort(int array[], int n){ int i; for (i=n/2;i&gt;0;i–) { HeapAdjust(array,i,n);//从下向上，从右向左调整 } for( i=n;i&gt;1;i–) { swap(array, 1, i); HeapAdjust(array, 1, i-1);//从上到下，从左向右调整 }}void HeapAdjust(int array[], int s, int n ){ int i,temp; temp = array[s]; for(i=2s;i&lt;=n;i=2) { if(i&lt;n&amp;&amp;array[i]&lt;array[i+1]) { i++; } if(temp&gt;=array[i]) { break; } array[s]=array[i]; s=i; } array[s]=temp;}void swap(int array[], int i, int j){ int temp; temp=array[i]; array[i]=array[j]; array[j]=temp;}123456789101112131415161718192021222324252627282930313233343536373839407 希尔排序7.1 过程希尔排序是插入排序改良的算法，希尔排序步长从大到小调整，第一次循环后面元素逐个和前面元素按间隔步长进行比较并交换，直至步长为1，步长选择是关键。 7.2 动图 7.3 核心程序（函数）//下面是插入排序void InsertSort( int array[], int n){ int i,j,temp; for( i=0;i&lt;n;i++ ) { if(array[i]&lt;array[i-1]) { temp=array[i]; for( j=i-1;array[j]&gt;temp;j–) { array[j+1]=array[j]; } array[j+1]=temp; } }}//在插入排序基础上修改得到希尔排序void SheelSort( int array[], int n){ int i,j,temp; int gap=n; //123456789101112131415do&#123; gap=gap/3+1; //~~~~~~~~~~~~~~~~~~ for( i=gap;i&lt;n;i++ ) &#123; if(array[i]&lt;array[i-gap]) &#123; temp=array[i]; for( j=i-gap;array[j]&gt;temp;j-=gap) &#123; array[j+gap]=array[j]; &#125; array[j+gap]=temp; &#125; &#125;&#125;while(gap&gt;1); //~ }1234567891011121314151617181920212223242526272829303132333435363738398 桶排序（基数排序和基数排序的思想）8.1 过程桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。 8.2 图解 8.3 核心程序 #include &lt;stdio.h&gt;int main(){ int a[11],i,j,t; for(i=0;i&lt;=10;i++) a[i]=0; //初始化为0 for(i=1;i&lt;=5;i++) //循环读入5个数 { scanf(&quot;%d&quot;,&amp;t); //把每一个数读到变量t中 a[t]++; //进行计数(核心行) } for(i=0;i&lt;=10;i++) //依次判断a[0]~a[10] for(j=1;j&lt;=a[i];j++) //出现了几次就打印几次 printf(&quot;%d &quot;,i); getchar();getchar(); //这里的getchar();用来暂停程序，以便查看程序输出的内容 //也可以用system(&quot;pause&quot;);等来代替 return 0;}123456789101112131415161718192021229 计数排序9.1 过程算法的步骤如下： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 9.2 图解 9.3 核心程序（函数）程序1： #define NUM_RANGE (100) //预定义数据范围上限，即K的值 void counting_sort(int ini_arr, int *sorted_arr, int n) //所需空间为 2n+k{ int *count_arr = (int *)malloc(sizeof(int) * NUM_RANGE); int i, j, k; //初始化统计数组元素为值为零 for(k=0; k&lt;NUM_RANGE; k++){ count_arr[k] = 0; } //统计数组中，每个元素出现的次数 for(i=0; i&lt;n; i++){ count_arr[ini_arr[i]]++; } //统计数组计数，每项存前N项和，这实质为排序过程 for(k=1; k&lt;NUM_RANGE; k++){ count_arr[k] += count_arr[k-1]; } //将计数排序结果转化为数组元素的真实排序结果 for(j=n-1 ; j&gt;=0; j--){ int elem = ini_arr[j]; //取待排序元素 int index = count_arr[elem]-1; //待排序元素在有序数组中的序号 sorted_arr[index] = elem; //将待排序元素存入结果数组中 count_arr[elem]--; //修正排序结果，其实是针对算得元素的修正 } free(count_arr); } 程序2：C++(最大最小压缩桶数)public static void countSort(int[] arr) { if (arr == null || arr.length &lt; 2) { return; } int min = arr[0]; int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { min = Math.min(arr[i], min); max = Math.max(arr[i], max); } int[] countArr = new int[max - min + 1]; for (int i = 0; i &lt; arr.length; i++) { countArr[arr[i] - min]++; } int index = 0; for (int i = 0; i &lt; countArr.length; i++) { while (countArr[i]– &gt; 0) { arr[index++] = i + min; }}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525310 基数排序10.1 过程基数排序是基于数据位数的一种排序算法。它有两种算法①LSD–Least Significant Digit first 从低位（个位）向高位排。②MSD– Most Significant Digit first 从高位向低位（个位）排。时间复杂度O(N*最大位数)。空间复杂度O(N)。 10.2 图解 对a[n]按照个位0~9进行桶排序： 对b[n]进行累加得到c[n]，用于b[n]中重复元素计数！！！b[n]中的元素为temp中的位置！！！跳跃的用++补上： temp数组为排序后的数组，写回a[n]。temp为按顺序倒出桶中的数据（联合b[n],c[n],a[n]得到），重复元素按顺序输出： 10.3 核心程序//基数排序//LSD 先以低位排，再以高位排//MSD 先以高位排，再以低位排void LSDSort(int a, int n){ assert(a); //判断a是否为空，也可以a为空||n&lt;2返回 int digit = 0; //最大位数初始化 for (int i = 0; i &lt; n; ++i) { //求最大位数 while (a[i] &gt; (pow(10,digit))) //pow函数要包含头文件math.h，pow(10,digit)=10^digit { digit++; } } int flag = 1; //位数 for (int j = 1; j &lt;= digit; ++j) { //建立数组统计每个位出现数据次数（Digit[n]为桶排序b[n]） int Digit[10] = { 0 }; for (int i = 0; i &lt; n; ++i) { Digit[(a[i] / flag)%10]++; //flag=1时为按个位桶排序 } //建立数组统计起始下标（BeginIndex[n]为个数累加c[n]，用于记录重复元素位置 //flag=1时，下标代表个位数值，数值代表位置，跳跃代表重复） int BeginIndex[10] = { 0 }; for (int i = 1; i &lt; 10; ++i) { //累加个数 BeginIndex[i] = BeginIndex[i - 1] + Digit[i - 1]; } //建立辅助空间进行排序 //下面两条可以用calloc函数实现 int *tmp = new int[n]; memset(tmp, 0, sizeof(int)n);//初始化 //联合各数组求排序后的位置存在temp中 for (int i = 0; i &lt; n; ++i) { int index = (a[i] / flag)%10; //桶排序和位置数组中的下标 //计算temp相应位置对应a[i]中的元素，++为BeginIndex数组数值加1 //跳跃间隔用++来补，先用再++ tmp[BeginIndex[index]++] = a[i]; } //将数据重新写回原空间 for (int i = 0; i &lt; n; ++i) { a[i] = tmp[i]; } flag = flag * 10; delete[] tmp; }}12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152附：1 完整程序框架（冒泡排序举例）1.1 VS2010程序 #include “stdafx.h” #include “stdio.h” #include &lt;stdlib.h&gt; void BubbleSort(int array[], int n){ int i,j,k,count1=0, count2=0; for(i=0; i&lt;n-1; i++) for(j=n-1; j&gt;i; j–) { count1++; if(array[j-1]&gt;array[j]) { count2++; k=array[j-1]; array[j-1]=array[j]; array[j]=k; } } printf(“总共的循环次序为：%d, 总共的交换次序为：%d\\n\\n”, count1, count2);} int main(int argc, _TCHAR* argv[]){ int as[]={0,1,2,3,4,6,8,5,9,7}; BubbleSort(as, 10); for(int i=0; i&lt;10; i++) { printf(“%d”, as[i]); } printf(“\\n\\n”); system(“pause”); return 0;}123456789101112131415161718192021222324252627282930313233341.2 执行程序（OJ） #include &lt;stdio.h&gt; void BubbleSort(int array[], int n){ int i,j,k,count1=0, count2=0; for(i=0; i&lt;n-1; i++) for(j=n-1; j&gt;i; j–) { count1++; if(array[j-1]&gt;array[j]) { count2++; k=array[j-1]; array[j-1]=array[j]; array[j]=k; } } printf(“总共的循环次序为：%d, 总共的交换次序为：%d\\n\\n”, count1, count2);} int main(){ int as[]={0,1,2,3,4,6,8,5,9,7}; BubbleSort(as, 10); int i=0; for(i=0; i&lt;10; i++) { printf(“%d”, as[i]); } return 0;}1234567891011121314151617181920212223242526272829302 关于交换的优化不用中间变量进行交换 if(A[j] &lt;= A[i]){ A[j] = A[j] + A[i]; A[i] = A[j] - A[i]; A[j] = A[j] - A[i];}123453 C语言实现数组动态输入 #include &lt;stdio.h&gt; #include &lt;assert.h&gt; //断言头文件 #include &lt;stdlib.h&gt; int main(int argc, char const *argv[]){ int size = 0; scanf(“%d”, &amp;size); //首先输入数组个数 assert(size &gt; 0); //判断数组个数是否非法 int *array = (int *)calloc(size, sizeof(int)); //动态分配数组 if(!R1) { return; //申请空间失败 } int i = 0; for (i = 0; i &lt; size; ++i) { scanf(&quot;%d&quot;, &amp;array[i]); } mergeSort(array, size); printArray(array, size); free(array); return 0; }123456789101112131415161718192021222324252627注：1.colloc与malloc类似,但是主要的区别是存储在已分配的内存空间中的值默认为0,使用malloc时,已分配的内存中可以是任意的值. 2.colloc需要两个参数,第一个是需要分配内存的变量的个数,第二个是每个变量的大小.","categories":[],"tags":[]},{"title":"三次握手四次挥手详解","slug":"三次握手，四次挥手","date":"2019-07-05T17:15:45.064Z","updated":"2019-07-05T17:16:59.423Z","comments":true,"path":"passages/三次握手，四次挥手/","link":"","permalink":"http://yoursite.com/passages/三次握手，四次挥手/","excerpt":"","text":"版权声明：转载需声明出处 https://blog.csdn.net/qq_38950316/article/details/81087809 本文经过借鉴书籍资料、他人博客总结出的知识点，欢迎提问 ​ 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 ​ 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 ​ 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 ​ 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 ​ 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 ​ PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。 字段 含义 URG 紧急指针是否有效。为1，表示某一位需要被优先处理 ACK 确认号是否有效，一般置为1。 PSH 提示接收端应用程序立即从TCP缓冲区把数据读走。 RST 对方要求重新建立连接，复位。 SYN 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 FIN 希望断开连接。 三次握手过程理解 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 四次挥手过程理解 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 常见面试题【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 ​ 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。","categories":[],"tags":[]},{"title":"Java快速排序","slug":"java快速排序","date":"2019-07-05T14:41:59.485Z","updated":"2019-07-05T14:43:42.990Z","comments":true,"path":"passages/java快速排序/","link":"","permalink":"http://yoursite.com/passages/java快速排序/","excerpt":"","text":"高快省的排序算法有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。 假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列： 3 1 2 5 4 6 9 7 10 8 在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？ 排序算法显神威方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。 首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下： 6 1 2 5 9 3 4 7 10 8到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下： 6 1 2 5 4 3 9 7 10 8 第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下： 3 1 2 5 4 6 9 7 10 8 到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。 OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。 左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧 如果你模拟的没有错，调整完毕之后的序列的顺序应该是： 2 1 3 5 4 OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下： 1 2 3 4 5 6 9 7 10 8 对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下 1 2 3 4 5 6 7 8 9 10 到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。 这是为什么呢？ 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200public class QuickSort &#123; public static void quickSort(int[] arr,int low,int high)&#123; int i,j,temp,t; if(low&gt;high)&#123; return; &#125; i=low; j=high; //temp就是基准位 temp = arr[low]; while (i&lt;j) &#123; //先看右边，依次往左递减 while (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123; j--; &#125; //再看左边，依次往右递增 while (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123; i++; &#125; //如果满足条件则交换 if (i&lt;j) &#123; t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; arr[i] = temp; //递归调用左半数组 quickSort(arr, low, j-1); //递归调用右半数组 quickSort(arr, j+1, high); &#125; public static void main(String[] args)&#123; int[] arr = &#123;10,7,2,4,7,62,3,4,2,1,8,9,19&#125;; quickSort(arr, 0, arr.length-1); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125;输出为1223447789101962","categories":[],"tags":[]},{"title":"Struts2笔记","slug":"Struts2笔记/strust_day01","date":"2019-07-04T10:11:30.663Z","updated":"2019-07-04T11:11:37.858Z","comments":true,"path":"passages/Struts2笔记/strust_day01/","link":"","permalink":"http://yoursite.com/passages/Struts2笔记/strust_day01/","excerpt":"","text":"struts2框架：概述：​ 是一个基于MVC设计模式的WEB层框架。 常见的web层框架​ struts2 ​ struts2 ​ springMVC ​ Webwork Web层框架基于前端控制器模型设计​ ![图一 前端控制器模型](D:\\学习很重要\\学习\\javaweb全套\\07-Struts2框架（学习4天）\\day01_Strust入门XML配置-action编写\\资料\\图一 前端控制器模型.bmp)","categories":[],"tags":[]},{"title":"spring笔记","slug":"spring笔记/springday01","date":"2019-07-04T10:11:30.644Z","updated":"2019-07-04T11:01:48.104Z","comments":true,"path":"passages/spring笔记/springday01/","link":"","permalink":"http://yoursite.com/passages/spring笔记/springday01/","excerpt":"","text":"spring:​ 概述：EE开发的 一站式 框架 ​ 一站式框架 ：有EE开发的每一层的解决方案。 ​ WEB层 ：SpringMVC ​ Service : Spring的bean管理，Spring声明式事务 ​ DAO层（持久层）： Spring 的 JDBC 模板，Spring的 ORM ​ IOC:(Inversion of Control 控制反转)​ Spring底层的IOC的实现原理：​ 工厂+反射+配置文件 –》实现程序解耦合 *&lt; bean id=”UserDAO” class=”xxx.UserDAOImpl”&gt; class BeanFactory{ ​ public static Object getBean(String id){ ​ //解析XML ​ //反射 ​ Class clazz=Class.forName(); ​ return clazz.newInstance(); ​ } } DI(依赖注入)：​ 前提必须有IOC的环境，spring管理这个类的时候将类的依赖的属性注入（设置）进来。 面向对象：依赖：​ class A{ } ​ class B{ ​ public void xxx(A a){ //B依赖了A ​ } } 继承: is a​ class A{ } ​ class B extends A{ } 聚合: has a​ bean:​ 标签： ​ id ：使用了约束中的唯一约束，里面不能出现特殊字符的。 ​ name：没有使用约束中的唯一约束（理论上可以出现重复的，但实际开发并不能出现的）。可以出现特殊字段 ​ class：对应的是要生成实例的类的全路径 ​ 作用范围的配置：（重点） ​ scope ：Bean的作用范围 ***`singleton`** ：默认：Spring会用单列模式创建这个对象。* ***`prototype`** ：多例模式。* **`request`** ：应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。 **`session`** ：应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。 **`globalsession`** ：应用在web项目中，必须在prolet环境下使用。但是如果没有这种环境，相对于session。","categories":[],"tags":[]},{"title":"Spring原理","slug":"spring笔记/1、spring原理","date":"2019-07-04T10:11:30.638Z","updated":"2019-07-04T11:12:44.808Z","comments":true,"path":"passages/spring笔记/1、spring原理/","link":"","permalink":"http://yoursite.com/passages/spring笔记/1、spring原理/","excerpt":"","text":"1、spring原理​ 内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。 Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过 配置类达到的。 Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象） 要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。Spring里用的最经典的一个设计模式就是：模板方法模式。(这里我都不介绍了，是一个很常用的设计模式)， Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了 也就基本上掌握了Spring.Spring AOP与IOC一、 IoC(Inversion of control): 控制反转1、IoC：概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系核心：bean工厂；在Spring中，bean工厂创建的各个实例称作bean二、AOP(Aspect-Oriented Programming): 面向方面编程1、 代理的两种方式：静态代理： 针对每个具体类分别编写代理类； 针对一个接口编写一个代理类；动态代理：针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类 2、动态代理:不用写代理类，虚拟机根据真实对象实现的接口产生一个类，通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。 ​ 1、产生动态代理的类: ​ java.lang.refect.Proxy ​ 2、装备必须实现InvocationHandler接口实现invoke方法 3、反射​ 什么是类的返射? ​ 通过类说明可以得到类的父类、实现的接口、内部类、构造函数、方法、属性并可以根据构造器实例化一个对象，唤起一个方法，取属性值，改属性值。如何得到一个类说明： ​ Class cls=类.class; ​ Class cls=对象.getClass(); ​ Class.forName(“类路径”); ​ 如何得到一个方法并唤起它? ​ Class cls=类.class; ​ Constructor cons=cls.getConstructor(new Class[]{String.class}); ​ Object obj=cons.newInstance(new Object[]{“aaa”}); ​ Method method=cls.getMethod(“方法名”,new Class[]{String.class,Integer.class}); ​ method.invoke(obj,new Object[]{“aa”,new Integer(1)}); 4、spring的三种注入方式是什么?​ setter ​ interface ​ constructor 5、spring的核心接口及核心配置文件是什么?​ FactoryBean:工厂bean主要实现ioc/di ​ ApplicationContext ac=new FileXmlApplicationContext(“applicationContext.xml”); ​ Object obj=ac.getBean(“id值”); 6、Spring框架的7个模块 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： ​ 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 ​ Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 ​ Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 ​ Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 ​ Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 ​ Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 ​ Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。","categories":[],"tags":[]},{"title":"SpringBoot笔记","slug":"springboot笔记/了解springboot基础","date":"2019-07-04T10:11:30.615Z","updated":"2019-07-04T11:07:35.593Z","comments":true,"path":"passages/springboot笔记/了解springboot基础/","link":"","permalink":"http://yoursite.com/passages/springboot笔记/了解springboot基础/","excerpt":"","text":"SpringBoot:​ 概述：其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 简介：​ SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决 。 特点SpringBoot所具备的特征有： （1）可以创建独立的Spring应用程序，并且基于其Maven或Grandel插件，可以创建可执行的JARs和WARs； （2）内嵌Tomcat或Jetty等Servlet容器； （3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置； （4）尽可能自动配置Spring容器； （5）提供准备好的特性，如指标、健康检查和外部化配置； （6）绝对没有代码生成，不需要XML配置。 重要策略​ SpringBoot框架中还有两个非常重要的策略：开箱即用 和 约定优于配置。开箱即用，Outofbox，是指在开发过程中，通过在MAVEN项目的pom文件中添加相关依赖包，然后使用对应注解来代替繁琐的XML配置文件以管理对象的生命周期。这个特点使得开发人员摆脱了复杂的配置工作以及依赖的管理工作，更加专注于业务逻辑。约定优于配置，Convention over configuration，是一种由SpringBoot本身来配置目标结构，由开发者在结构中添加信息的软件设计范式。这一特点虽降低了部分灵活性，增加了BUG定位的复杂性，但减少了开发人员需要做出决定的数量，同时减少了大量的XML配置，并且可以将代码编译、测试和打包等工作自动化。 SpringBoot应用系统开发模板的基本架构设计从前端到后台进行说明：前端常使用模板引擎，主要有FreeMarker和Thymeleaf，它们都是用Java语言编写的，渲染模板并输出相应文本，使得界面的设计与应用的逻辑分离，同时前端开发还会使用到Bootstrap、AngularJS、JQuery等；在浏览器的数据传输格式上采用Json，非xml，同时提供RESTfulAPI；SpringMVC框架用于数据到达服务器后处理请求；到数据访问层主要有Hibernate、MyBatis、JPA等持久层框架；数据库常用MySQL；开发工具推荐IntelliJIDEA。","categories":[],"tags":[]},{"title":"","slug":"springboot笔记/springboot深入解读","date":"2019-07-04T10:11:30.614Z","updated":"2019-07-04T05:43:01.171Z","comments":true,"path":"passages/springboot笔记/springboot深入解读/","link":"","permalink":"http://yoursite.com/passages/springboot笔记/springboot深入解读/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mybatis笔记","slug":"Mybatis笔记/Mybatis_day01","date":"2019-07-04T10:11:30.597Z","updated":"2019-07-04T11:13:30.641Z","comments":true,"path":"passages/Mybatis笔记/Mybatis_day01/","link":"","permalink":"http://yoursite.com/passages/Mybatis笔记/Mybatis_day01/","excerpt":"","text":"Mybatis:（类似于hibernate的持久层框架）​ 概述：持久层框架 ​ MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 每个MyBatis应用程序主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactoryBuilder可以从一个xml配置文件或者一个预定义的配置类的实例获得。 用xml文件构建SqlSessionFactory实例是非常简单的事情。推荐在这个配置中使用类路径资源（classpath resource)，但你可以使用任何Reader实例，包括用文件路径或file://开头的url创建的实例。MyBatis有一个实用类—-Resources，它有很多方法，可以方便地从类路径及其它位置加载资源。 持久层框架编辑 Hibernate Hibernate [1] 是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。Eclipse平台下的Hibernate辅助开发工具:【Hibernate Synchronizer】【MiddlegenIDE】 MyBatis 使用MyBatis 提供的ORM机制，对业务逻辑实现人员而言，面对的是纯粹的Java对象， 这一层与通过Hibernate 实现ORM 而言基本一致，而对于具体的数据操作，Hibernate 会自动生成SQL 语句，而MyBatis则要求开发者编写具体的SQL 语句。相对Hibernate等 “全自动”ORM机制而言，MyBatis 以SQL开发的工作量和数据库移植性上的让步，为系统 设计提供了更大的自由空间。作为“全自动”ORM 实现的一种有益补充，MyBatis 的出现显 得别具意义。 -","categories":[],"tags":[]},{"title":"Maven 简述","slug":"maven笔记/maven_day01","date":"2019-07-04T10:11:30.572Z","updated":"2019-07-04T11:14:07.412Z","comments":true,"path":"passages/maven笔记/maven_day01/","link":"","permalink":"http://yoursite.com/passages/maven笔记/maven_day01/","excerpt":"","text":"maven：（说白了就是对jar包的管理并给出坐标的过程）​ 概述：项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。 Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长","categories":[],"tags":[]},{"title":"Maven 核心原理","slug":"maven笔记/Maven 核心原理","date":"2019-07-04T10:11:30.569Z","updated":"2019-07-10T15:01:28.085Z","comments":true,"path":"passages/maven笔记/Maven 核心原理/","link":"","permalink":"http://yoursite.com/passages/maven笔记/Maven 核心原理/","excerpt":"","text":"Maven 核心原理Maven 是每一位Java工程师每天都会接触的工具, 但据我所知其实很多人对Maven理解的并不深, 只把它当做一个依赖管理工具(下载依赖、打包), Maven很多核心的功能反而没用上. 最近重读 Maven实战, 虽然这本书年岁较老(10年出版: 那还是Hudson年代), 但绝大部分还是很值得参考的. 本文讲述Maven的核心原理和概念, 因此还是大纲参考了这本书, 但细节大多参考的Maven的官方文档以及网友释出的博客. 本文主要讲解Maven的: 坐标与依赖、仓库、生命周期与插件、模块聚合、模块继承等概念, 并通过一个开发Maven插件的实例来深入了解Maven的核心机制. 而对于 如何配置Maven、Nexus私服、Jenkins持续集成、Maven测试、构建Web、资源过滤、自定义Archetype 等相对简单、讲解繁琐且网上有大量实践案例的内容没有涉及. 本文的目标是希望读者能够通过本文能对Maven核心原理有个相对深入的理解. 坐标与依赖为了能够自动化地解析任何一个Java构件, Maven必须将它们唯一标识, 这就是依赖管理的底层基础-坐标. 坐标在数学中, 任何一个坐标可以唯一确定一个“点”. Maven 坐标为Java构件引入了秩序, 任何一个构件都必须明确定义自己的坐标, 坐标元素包括groupId、artifactId、version、packaging、classfier: org.apache.commonscommons-lang33.4jar1234元素 描述 extgroupId 定义当前模块隶属的实际Maven项目, 表示方式与Java包类似 groupId不应直接对应项目隶属的公司/组织(一个公司/组织下可能会有很多的项目).artifactId 定义实际项目中的一个Maven模块 推荐使用项目名作为artifactId前缀, 如:commons-lang3以commons作为前缀(因为Maven打包默认以artifactId作为前缀)version 定义当前项目所处版本(如1.0-SNAPSHOT、4.2.7.RELEASE、1.2.15、14.0.1-h-3 等) Maven版本号定义约定: &lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;里程碑版本&gt;packaging 定义Maven项目打包方式, 通常打包方式与所生成构件扩展名对应 有jar(默认)、war、pom、maven-plugin等.classifier 用来帮助定义构建输出的一些附属构件(如javadoc、sources) 不能直接定义项目的classifier(因为附属构件不是由项目默认生成, 须有附加插件的帮助)依赖Maven最著名的(也是几乎每个人最先接触到的)就是Maven的依赖管理, 它使得我们不必再到开源项目的官网一个个下载开源组件, 然后再一个个放入classpath. 一个依赖声明可以包含如下元素: org.springframework spring-web 4.2.7.RELEASE &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 依赖传递 Maven依赖传递机制会自动加载我们引入的依赖包的依赖, 而不必去手动指定(好拗口(⊙﹏⊙)b : This allows you to avoid needing to discover and specify the libraries that your own dependencies require, and including them automatically). 如: 我们的项目依赖了spring-core, 而spring-core又依赖了commons-logging: 有了依赖传递机制, 在项目中添加了spring-core依赖时就不用再去考虑它依赖了什么, 也不用担心引入多余的依赖. Maven会解析各个直接依赖的POM, 将必要的间接依赖以传递性依赖的形式引入到当前目录中(inherits from its parents, or from its dependencies, and so on).(依赖调节原则: 1. 路径最近者优先; 2. 第一声明者优先.)更多传递依赖信息可参考: Dependency Mechanism-Transitive Dependencies. 声明一个或者多个项目依赖, 可以包含的元素有: 元素 描述 ExtgroupId、artifactId和version 依赖的基本坐标(最最重要)type 依赖的类型, 对应于项目坐标定义的packaging 默认jarscope 依赖的范围, 用来控制依赖与三种classpath(编译classpath、测试classpath、运行classpath)的关系 包含compile、provided、runtime、test、system和import 6种, 详见:Dependency Scope.optional 依赖是否可选 假如一个Jar包支持MySQL与Oracle两种DB, 因此其构建时必须添加两类驱动, 但用户使用时只会选择一种DB. 此时对A、B就可使用optional可选依赖exclusions 排除传递性依赖 传递性依赖极大的简化了项目依赖的管理, 但也会引入Jar包版本冲突等问题, 此时就需要对传递性依赖进行排除. optional与exclusions详细可参考: Optional Dependencies and Dependency Exclusions依赖管理Maven提供了dependency插件可以对Maven项目依赖查看以及优化, 如$ mvn dependency:tree可以查看当前项目的依赖树, 详见$ mvn dependency:help.Maven 仓库Maven 中, 任何一个依赖、插件或项目构建的输出, 都可称为构件, 而Maven仓库就是集中存储这些构件的地方. 两类仓库Maven仓库可简单分成两类: 本地仓库与远程仓库. 当Maven根据坐标寻找构件时, 它会首先检索本地仓库, 如果本地存在则直接使用, 否则去远程仓库下载. 本地仓库: 默认地址为~/.m2/, 一个构件只有在本地仓库存在之后, 才能由Maven项目使用.远程仓库: 远程仓库又可简单分成两类: 中央仓库和私服.由于原始的本地仓库是空的, Maven必须至少知道一个远程仓库才能在执行命令时下载需要的构件, 中央仓库就是这样一个默认的远程仓库.关于仓库的详细配置可参考: Settings Reference 的 Servers、Mirrors、Profiles 等章节. 私服 私服是一种特殊的远程仓库, 它设在局域网内, 通过代理广域网上的远程仓库, 供局域网内的Maven用户使用.当需要下载构件时, Maven客户端先向私服请求, 如果私服不存在该构件, 则从外部的远程仓库下载, 并缓存在私服上, 再为客户提供下载服务. 此外, 一些无法从外部仓库下载到的构建也能从本地上传到私服供大家使用(如公司内部二方包、Oracle的JDBC启动等). 为了节省带宽和时间, 一般在公司内部都会架设一台Maven私服, 但将公司内部项目部署到私服还需要对POM做如下配置: ... releases http://mvn.server.com/nexus/content/repositories/releases/ snapshots http://mvn.server.com/nexus/content/repositories/snapshots/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 repository表示发布版本构件的仓库, snapshotRepository代表快照版本的仓库. id为该远程仓库唯一标识, url表示该仓库地址. 配置正确后, 执行$ mvn clean deploy则可以将项目构建输出的构件部署到对应配置的远程仓库. 注: 往远程仓库部署构件时, 往往需要认证: 需要在settings.xml中创建servers元素, 其id与仓库的id匹配, 详见: Password Encryption. 仓库搜索推荐几个可用的Maven仓库搜索服务:MVNrepository: http://mvnrepository.com/Sonatype Nexus: https://repository.sonatype.org/生命周期与插件Maven 将所有项目的构建过程统一抽象成一套生命周期: 项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成 … 几乎所有项目的构建,都能映射到这一组生命周期上. 但生命周期是抽象的(Maven的生命周期本身是不做任何实际工作), 任务执行(如编译源代码)均交由插件完成. 其中每个构建步骤都可以绑定一个或多个插件的目标,而且Maven为大多数构建步骤都编写并绑定了默认插件.当用户有特殊需要的时候, 也可以配置插件定制构建行为, 甚至自己编写插件. 生命周期Maven 拥有三套相互独立的生命周期: clean、default 和 site, 而每个生命周期包含一些phase阶段, 阶段是有顺序的, 并且后面的阶段依赖于前面的阶段. 而三套生命周期相互之间却并没有前后依赖关系, 即调用site周期内的某个phase阶段并不会对clean产生任何影响. cleanclean生命周期的目的是清理项目: 执行如$ mvn clean; defaultdefault生命周期定义了真正构建时所需要执行的所有步骤: 执行如$ mvn clean install; sitesite生命周期的目的是建立和发布项目站点: Maven能够基于POM所包含的信息,自动生成一个友好的站点,方便团队交流和发布项目信息 执行命令如$ mvn clean deploy site-deploy; 更多 Maven 生命周期介绍可以参考: Introduction to the Build Lifecycle、Lifecycles Reference. 插件生命周期的阶段phase与插件的目标goal相互绑定, 用以完成实际的构建任务. 而对于插件本身, 为了能够复用代码,它往往能够完成多个任务, 这些功能聚集在一个插件里,每个功能就是一个目标.如:$ mvn compiler:compile: 冒号前是插件前缀, 后面是该插件目标(即: maven-compiler-plugin的compile目标).而该目标绑定了default生命周期的compile阶段: 因此, 他们的绑定能够实现项目编译的目的. 内置绑定为了能让用户几乎不用任何配置就能使用Maven构建项目, Maven 默认为一些核心的生命周期绑定了插件目标, 当用户通过命令调用生命周期阶段时, 对应的插件目标就会执行相应的逻辑. clean生命周期阶段绑定生命周期阶段 插件目标pre-clean -clean maven-clean-plugin:cleanpost-clean -default声明周期阶段绑定生命周期阶段 插件目标 执行任务process-resources maven-resources-plugin:resources 复制主资源文件到主输出目录compile maven-compiler-plugin:compile 编译主代码到主输出目录process-test-resources maven-resources-plugin:testResources 复制测试资源文件到测试输出目录test-compile maven-compiler-plugin:testCompile 编译测试代码到测试输出目录test maven-surefire-plugin:test 执行测试用例package maven-jar-plugin:jar 打jar包install maven-install-plugin:install 将项目输出安装到本地仓库deploy maven-deploy-plugin:deploy 将项目输出部署到远程仓库注: 上表只列出了打包方式为jar且拥有插件绑定关系的阶段, 其他打包类型生命周期的默认绑定关系可参考: Built-in Lifecycle Bindings、Plugin Bindings for default Lifecycle Reference. site生命周期阶段绑定生命周期阶段 插件目标pre-site -site maven-site-plugin:sitepost-site -site-deploy maven-site-plugin:deploy自定义绑定除了内置绑定以外, 用户还能够自定义将某个插件目标绑定到生命周期的某个阶段上. 如创建项目的源码包, maven-source-plugin插件的jar-no-fork目标能够将项目的主代码打包成jar文件, 可以将其绑定到verify阶段上: org.apache.maven.plugins maven-source-plugin 3.0.0 attach-sources verify jar-no-fork 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 executions下每个execution子元素可以用来配置执行一个任务. 关于Maven插件的自定义绑定及其他详细配置可参考: Guide to Configuring Plug-ins. 插件查询在线Maven 官方插件https://maven.apache.org/plugins/index.htmlCodeHaus 插件http://www.mojohaus.org/plugins.htmlmaven-help-pluginmvn help:describe -Dplugin=org.apache.maven.plugins:maven-source-plugin[:3.0.0] [-Ddetail] [-Dgoal=jar-no-fork]1聚合与继承Maven的聚合特性(aggregation)能够使项目的多个模块聚合在一起构建, 而继承特性(inheritance)能够帮助抽取各模块相同的依赖、插件等配置,在简化模块配置的同时, 保持各模块一致. 模块聚合随着项目越来越复杂(需要解决的问题越来越多、功能越来越重), 我们更倾向于将一个项目划分几个模块并行开发, 如: 将feedcenter-push项目划分为client、core和web三个模块, 而我们又想一次构建所有模块, 而不是针对各模块分别执行$ mvn命令. 于是就有了Maven的模块聚合 -&gt; 将feedcenter-push作为聚合模块将其他模块聚集到一起构建: 聚合POM聚合模块POM仅仅是帮助聚合其他模块构建的工具, 本身并无实质内容: &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;feedcenter-push-client&lt;/module&gt; &lt;module&gt;feedcenter-push-core&lt;/module&gt; &lt;module&gt;feedcenter-push-web&lt;/module&gt; &lt;/modules&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 通过在一个打包方式为pom的Maven项目中声明任意数量的module以实现模块聚合: packaging: pom, 否则无法聚合构建. modules: 实现聚合的核心,module值为被聚合模块相对于聚合POM的相对路径, 每个被聚合模块下还各自包含有pom.xml、src/main/java、src/test/java等内容, 离开聚合POM也能够独立构建(注: 模块所处目录最好与其artifactId一致). Tips: 推荐将聚合POM放在项目目录的最顶层, 其他模块作为聚合模块的子目录. 其他关于聚合与反应堆介绍可参考: Guide to Working with Multiple Modules. 模块继承在面向对象中, 可以通过类继承实现复用. 在Maven中同样也可以创建POM的父子结构, 通过在父POM中声明一些配置供子POM继承来实现复用与消除重复: 父POM与聚合类似, 父POM的打包方式也是pom, 因此可以继续复用聚合模块的POM(这也是在开发中常用的方式): &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;feedcenter-push-client&lt;/module&gt; &lt;module&gt;feedcenter-push-core&lt;/module&gt; &lt;module&gt;feedcenter-push-web&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;finalName&gt;feedcenter-push&lt;/finalName&gt; &lt;warName&gt;${finalName}.war&lt;/warName&gt; &lt;spring.version&gt;4.0.6.RELEASE&lt;/spring.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;warExplodedDirectory&gt;exploded/${warName}&lt;/warExplodedDirectory&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 dependencyManagement: 能让子POM继承父POM的配置的同时, 又能够保证子模块的灵活性: 在父POMdependencyManagement元素配置的依赖声明不会实际引入子模块中, 但能够约束子模块dependencies下的依赖的使用(子模块只需配置groupId与artifactId, 见下). pluginManagement: 与dependencyManagement类似, 配置的插件不会造成实际插件的调用行为, 只有当子POM中配置了相关plugin元素, 才会影响实际的插件行为. 2. 子POM &lt;parent&gt; &lt;groupId&gt;com.vdian.feedcenter&lt;/groupId&gt; &lt;artifactId&gt;feedcenter-push&lt;/artifactId&gt; &lt;version&gt;1.0.0.SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;feedcenter-push-client&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 元素继承 可以看到, 子POM中并未定义模块groupId与version, 这是因为子POM默认会从父POM继承了如下元素: groupId、versiondependenciesdevelopers and contributorsplugin lists (including reports)plugin executions with matching idsplugin configurationresources因此所有的springframework都省去了version、junit还省去了scope, 而且插件还省去了executions与configuration配置, 因为完整的声明已经包含在父POM中.优势: 当依赖、插件的版本、配置等信息在父POM中声明之后, 子模块在使用时就无须声明这些信息, 也就不会出现多个子模块使用的依赖版本不一致的情况, 也就降低了依赖冲突的几率. 另外如果子模块不显式声明依赖与插件的使用, 即使已经在父POM的dependencyManagement、pluginManagement中配置了, 也不会产生实际的效果. 推荐: 模块继承与模块聚合同时进行,这意味着, 你可以为你的所有模块指定一个父工程, 同时父工程中可以指定其余的Maven模块作为它的聚合模块. 但需要遵循以下三条规则: 在所有子POM中指定它们的父POM;将父POM的packaging值设为pom;在父POM中指定子模块/子POM的目录.注: parent元素内还包含一个relativePath元素, 用于指定父POM的相对路径, 默认../pom.xml. 超级pom-约定优先于配置任何一个Maven项目都隐式地继承自超级POM, 因此超级POM的大量配置都会被所有的Maven项目继承, 这些配置也成为了Maven所提倡的约定. 4.0.0 central Central Repository https://repo.maven.apache.org/maven2 default false central Central Repository https://repo.maven.apache.org/maven2 default false never ${project.basedir}/target ${project.build.directory}/classes ${project.artifactId}-${project.version} ${project.build.directory}/test-classes ${project.basedir}/src/main/java ${project.basedir}/src/main/scripts ${project.basedir}/src/test/java ${project.basedir}/src/main/resources ${project.basedir}/src/test/resources &lt;!-- 为核心插件设定版本 --&gt; &lt;pluginManagement&gt; &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt; &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.2-beta-5&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; ${project.build.directory}/site release-profile &lt;activation&gt; &lt;property&gt; &lt;name&gt;performRelease&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/activation&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-javadocs&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 附: Maven继承与组合的其他信息还可参考: Introduction to the POM. Maven Plugin 开发几乎100%的场景都不用我们自己开发Maven插件, 但理解插件开发可以使我们更加深入的理解Maven. 下面我们实际开发一个用于统计代码行数的插件 lc-maven-plugin. 创建plugin项目mvn archetype:generate -DgroupId=com.fq.plugins -DartifactId=lc-maven-plugin -Dversion=0.0.1-SNAPSHOT -DarchetypeArtifactId=maven-archetype-plugin -DinteractiveMode=false -DarchetypeCatalog=internal12345使用maven-archetype-plugin Archetype可以快速创建一个Maven插件项目(关于Maven Archetype可参考What is an Archetype 、Creating Archetypes[注: 该文档介绍的是Archetype 1.x编写, 2.x内附链接]). pom.xml插件本身也是Maven项目, 特殊之处在于packaging方式为maven-plugin: &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fq.plugins&lt;/groupId&gt; &lt;artifactId&gt;lc-maven-plugins&lt;/artifactId&gt; &lt;packaging&gt;maven-plugin&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.maven.plugin-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-plugin-annotations&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 maven-plugin 打包方式能控制Maven为其在生命周期阶段绑定插件处理的相关目标. 编写目标MojoWhat is a Mojo? A mojo is a M aven plain O ld J ava O bject. Each mojo is an executable goal in Maven, and a plugin is a distribution of one or more related mojos. /** @author jifang @since 16/10/9 上午11:33. */ @Mojo(name = “lc”, defaultPhase = LifecyclePhase.VERIFY) public class LCMavenMojo extends AbstractMojo { private static final List DEFAULT_FILES = Arrays.asList(“java”, “xml”, “properties”); @Parameter(defaultValue = “${project.basedir}”, readonly = true) private File baseDir; @Parameter(defaultValue = “${project.build.sourceDirectory}”, readonly = true) private File srcDir; @Parameter(defaultValue = “${project.build.testSourceDirectory}”, readonly = true) private File testSrcDir; @Parameter(defaultValue = “${project.build.resources}”, readonly = true) private List resources; @Parameter(defaultValue = “${project.build.testResources}”, readonly = true) private List testResources; @Parameter(property = “lc.file.includes”) private Set includes = new HashSet&lt;&gt;(); private Log logger = getLog(); @Override public void execute() throws MojoExecutionException, MojoFailureException { if (includes.isEmpty()) { logger.debug(&quot;includes/lc.file.includes is empty!&quot;); includes.addAll(DEFAULT_FILES); } logger.info(&quot;includes: &quot; + includes); try { long lines = 0; lines += countDir(srcDir); lines += countDir(testSrcDir); for (Resource resource : resources) { lines += countDir(new File(resource.getDirectory())); } for (Resource resource : testResources) { lines += countDir(new File(resource.getDirectory())); } logger.info(&quot;total lines: &quot; + lines); } catch (IOException e) { logger.error(&quot;error: &quot;, e); throw new MojoFailureException(&quot;execute failure: &quot;, e); } } private LineProcessor lp = new LineProcessor() { private long line = 0; @Override public boolean processLine(String fileLine) throws IOException { if (!Strings.isNullOrEmpty(fileLine)) { ++this.line; } return true; } @Override public Long getResult() { long result = line; this.line = 0; return result; } }; private long countDir(File directory) throws IOException { long lines = 0; if (directory.exists()) { Set&lt;File&gt; files = new HashSet&lt;&gt;(); collectFiles(files, directory); for (File file : files) { lines += CharStreams.readLines(new FileReader(file), lp); } String path = directory.getAbsolutePath().substring(baseDir.getAbsolutePath().length()); logger.info(&quot;path: &quot; + path + &quot;, file count: &quot; + files.size() + &quot;, total line: &quot; + lines); logger.info(&quot;\\t-&gt; files: &quot; + files.toString()); } return lines; } private void collectFiles(Set&lt;File&gt; files, File file) { if (file.isFile()) { String fileName = file.getName(); int index = fileName.lastIndexOf(&quot;.&quot;); if (index != -1 &amp;&amp; includes.contains(fileName.substring(index + 1))) { files.add(file); } } else { File[] subFiles = file.listFiles(); for (int i = 0; subFiles != null &amp;&amp; i &lt; subFiles.length; ++i) { collectFiles(files, subFiles[i]); } } }}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@Parameter: 配置点, 提供Mojo的可配置参数. 大部分Maven插件及其目标都是可配置的, 通过配置点, 用户可以自定义插件行为: com.fq.plugins lc-maven-plugins 0.0.1-SNAPSHOT lc verify lc java lua json xml properties 1234567891011121314151617181920212223execute(): 实际插件功能;异常: execute()方法可以抛出以下两种异常:MojoExecutionException: Maven执行目标遇到该异常会显示 BUILD FAILURE 错误信息, 表示在运行期间发生了预期的错误;MojoFailureException: 表示运行期间遇到了未预期的错误, 显示 BUILD ERROR 信息. 测试&amp;执行通过mvn clean install将插件安装到仓库后, 就可将其配置到实际Maven项目中, 用于统计项目代码了: $ mvn com.fq.plugins:lc-maven-plugins:0.0.1-SNAPSHOT:lc [-Dlc.file.includes=js,lua] [-X]1注: 其他关于Maven Plugin开发可参考:Plugin Developers Centre、Maven API Reference. 参考 &amp; 扩展Maven实战持续部署, 并不简单maven.apache.orgGuide to creating assembliesMaven入门指南（一）用 Maven 做项目构建项目管理: Maven 让事情变得简单Maven开始逃离 XML 阵营Apache Maven JDeps插件3.0.0版本发布Maven实战（六）——Gradle，构建工具的未来？Maven实战（七）——常用Maven插件介绍（上）Maven实战（八）——常用Maven插件介绍（下）Maven实战（九）——打包的技巧 Gradle 2.0发布：简单、快速、支持Java 8作者：菜鸟-翡青来源：CSDN原文：https://blog.csdn.net/zjf280441589/article/details/53044308/版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[],"tags":[]},{"title":"JDBC简述","slug":"JDBC笔记/JDBC","date":"2019-07-04T10:11:30.566Z","updated":"2019-07-04T11:14:45.740Z","comments":true,"path":"passages/JDBC笔记/JDBC/","link":"","permalink":"http://yoursite.com/passages/JDBC笔记/JDBC/","excerpt":"","text":"JDBC:（Java data base Connectivity (java数据库连接)）​ 是一种执行SQL语句的javaAPI，可以为多种关系数据库提供统一访问，它由一组用java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 ​ JDBC连接数据库步骤：1.加载驱动 2.连接数据库 3.使用语句操作数据库 4.关闭数据库连接，释放资源 ##","categories":[],"tags":[]},{"title":"面向对象编程","slug":"java杂记/面向对象编程","date":"2019-07-04T10:11:30.563Z","updated":"2019-07-04T10:45:25.254Z","comments":true,"path":"passages/java杂记/面向对象编程/","link":"","permalink":"http://yoursite.com/passages/java杂记/面向对象编程/","excerpt":"","text":"面向对象编程：概述​ 面向对象程序设计（Object OrientedProgramming，OOP）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。 面向对象程序设计方法是尽可能模拟人类的思维方式，使得软件的开发方法与过程尽可能接近人类认识世界、解决现实问题的方法和过程，也即使得描述问题的问题空间与问题的解决方案空间在结构上尽可能一致，把客观世界中的实体抽象为问题域中的对象。 面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，对象是类的实例化。对象间通过消息传递相互通信，来模拟现实世界中不同实体间的联系。在面向对象的程序设计中，对象是组成程序的基本模块。 特点1、封装性： 封装是指将一个计算机系统中的数据以及与这个数据相关的一切操作语言（即描述每一个对象的属性以及其行为的程序代码）组装到一起，一并封装在一个有机的实体中，把它们封装在一个“模块”中，也就是一个类中，为软件结构的相关部件所具有的模块性提供良好的基础。在面向对象技术的相关原理以及程序语言中，封装的最基本单位是对象，而使得软件结构的相关部件的实现“高内聚、低耦合”的“最佳状态”便是面向对象技术的封装性所需要实现的最基本的目标。对于用户来说，对象是如何对各种行为进行操作、运行、实现等细节是不需要刨根问底了解清楚的，用户只需要通过封装外的通道对计算机进行相关方面的操作即可。大大地简化了操作的步骤，使用户使用起计算机来更加高效、更加得心应手。 2、继承性： 继承性是面向对象技术中的另外一个重要特点，其主要指的是两种或者两种以上的类之间的联系与区别。继承，顾名思义，是后者延续前者的某些方面的特点，而在面向对象技术则是指一个对象针对于另一个对象的某些独有的特点、能力进行复制或者延续。如果按照继承源进行划分，则可以分为单继承（一个对象仅仅从另外一个对象中继承其相应的特点）与多继承（一个对象可以同时从另外两个或者两个以上的对象中继承所需要的特点与能力，并且不会发生冲突等现象）；如果从继承中包含的内容进行划分，则继承可以分为四类，分别为取代继承（一个对象在继承另一个对象的能力与特点之后将父对象进行取代）、包含继承（一个对象在将另一个对象的能力与特点进行完全的继承之后，又继承了其他对象所包含的相应内容，结果导致这个对象所具有的能力与特点大于等于父对象，实现了对于父对象的包含）、受限继承、特化继承。 3、多态性： 从宏观的角度来讲，多态性是指在面向对象技术中，当不同的多个对象同时接收到同一个完全相同的消息之后，所表现出来的动作是各不相同的，具有多种形态；从微观的角度来讲，多态性是指在一组对象的一个类中，面向对象技术可以使用相同的调用方式来对相同的函数名进行调用，即便这若干个具有相同函数名的函数所表示的函数是不同的。 [2]","categories":[],"tags":[]},{"title":"面向切面编程","slug":"java杂记/面向切面编程","date":"2019-07-04T10:11:30.561Z","updated":"2019-07-04T10:56:21.044Z","comments":true,"path":"passages/java杂记/面向切面编程/","link":"","permalink":"http://yoursite.com/passages/java杂记/面向切面编程/","excerpt":"","text":"面向切面编程：​ Aspect Oriented Programming(AOP)，面向切面编程，是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。比如我们最常见的就是日志记录了，举个例子，我们现在提供一个查询学生信息的服务，但是我们希望记录有谁进行了这个查询。如果按照传统的OOP的实现的话，那我们实现了一个查询学生信息的服务接口(StudentInfoService)和其实现 类 （StudentInfoServiceImpl.java），同时为了要进行记录的话，那我们在实现类(StudentInfoServiceImpl.java)中要添加其实现记录的过程。这样的话，假如我们要实现的服务有多个呢？那就要在每个实现的类都添加这些记录过程。这样做的话就会有点繁琐，而且每个实现类都与记录服务日志的行为紧耦合，违反了面向对象的规则。那么怎样才能把记录服务的行为与业务处理过程中分离出来呢？看起来好像就是查询学生的服务自己在进行，但却是背后日志记录对这些行为进行记录，并且查询学生的服务不知道存在这些记录过程，这就是我们要讨论AOP的目的所在。AOP的编程，好像就是把我们在某个方面的功能提出来与一批对象进行隔离，这样与一批对象之间降低了耦合性，可以就某个功能进行编程。","categories":[],"tags":[]},{"title":"工厂模式","slug":"java杂记/工厂模式","date":"2019-07-04T10:11:30.559Z","updated":"2019-07-04T10:44:28.583Z","comments":true,"path":"passages/java杂记/工厂模式/","link":"","permalink":"http://yoursite.com/passages/java杂记/工厂模式/","excerpt":"","text":"工厂方法模式概述：​ 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。 优点：​ 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有代码，后期维护容易，增强了系统的扩展性 缺点：​ 需要额外的编写代码，增加了工作量 案例：","categories":[],"tags":[]},{"title":"成为一个高效的丶合理的决策者","slug":"要成为一个高效的丶合理的决策者，你必须：","date":"2019-07-04T02:27:43.626Z","updated":"2019-07-04T04:12:56.879Z","comments":true,"path":"passages/要成为一个高效的丶合理的决策者，你必须：/","link":"","permalink":"http://yoursite.com/passages/要成为一个高效的丶合理的决策者，你必须：/","excerpt":"","text":"要成为一个高效的丶合理的决策者，你必须：1.制定出最根本的目标和需求，并反复说出来以提醒自己。你所作出的决策应该有助于自己扫除障碍，为实现目标丶满足需求而创造机会。2.无论何时，都要逐个解决问题，做出决策，并尽可能清楚丶准确地陈述当前情形和其他备选决策。3.仔细研究备选决策所处的环境，搞清楚自己要做的决策，并认清楚每种备选决策可能产生的后果。要区分清楚：哪些决策你可以主动控制，而哪些决策是强加与你的。把精力集中在那些最重要的以及你可以施加最大影响的决策上。4.确认你需要哪些信息，并主动寻找它们。5.认真分析并解释收集到的信息，得出合理推论。6.确认自己可以有哪些行动。短期内你能做什么？长期呢？看到自己在金钱丶时间和权力上存在哪些不足。7.评价你在这种情况下可以做出的选择，充分考虑每种选择的优缺点。8.根据所做决策采取相应的策略，并按这种策略行事，包括立即行动或者谨慎的观望策略。9.行动时，一旦后果开始出现，就要对它进行监控。如果情况需要，要随时准备好修改自己的策略，随着你掌握的信息越来越多，要准备好改变自己的策略丶分析或者对决策种类的描述。","categories":[],"tags":[]},{"title":"first blog","slug":"README","date":"2019-07-03T16:00:25.064Z","updated":"2019-07-04T04:40:53.549Z","comments":true,"path":"passages/README/","link":"","permalink":"http://yoursite.com/passages/README/","excerpt":"","text":"Hello yierA brand new default theme for Hexo. Preview InstallationInstall1$ git clone https://github.com/hexojs/hexo-theme-landscape.git themes/landscape Landscape requires Hexo 2.4 and above. If you would like to enable the RSS, the hexo-generate-feed plugin is also required. EnableModify theme setting in _config.yml to landscape. Update12cd themes/landscapegit pull Configuration123456789101112131415161718192021222324# Headermenu: Home: / Archives: /archivesrss: /atom.xml# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- category- tag- tagcloud- archives- recent_posts# Miscellaneousgoogle_analytics:favicon: /favicon.pngtwitter:google_plus: menu - Navigation menu rss - RSS link excerpt_link - “Read More” link at the bottom of excerpted articles. false to hide the link. fancybox - Enable Fancybox sidebar - Sidebar style. You can choose left, right, bottom or false. widgets - Widgets displaying in sidebar google_analytics - Google Analytics ID favicon - Favicon path twitter - Twiiter ID google_plus - Google+ ID FeaturesFancyboxLandscape uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting. Landscape provides 5 built-in widgets: category tag tagcloud archives recent_posts All of them are enabled by default. You can edit them in widget setting. DevelopmentRequirements Grunt 0.4+ Hexo 2.4+ Grunt tasks default - Download Fancybox and Font Awesome. fontawesome - Only download Font Awesome. fancybox - Only download Fancybox. clean - Clean temporarily files and downloaded files.","categories":[],"tags":[]}]}